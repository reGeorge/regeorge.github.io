---
title: 《effective java》阅读笔记
date: 2025-03-16 16:27:45
tags: 笔记
---

## 创建和销毁对象
### 条目1：考虑用静态工厂方法代替构造器
概述：静态工厂方法比构造器更灵活，可以控制实例的创建。
问题：静态工厂方法相比构造器有哪些优势？

### 条目2：遇到多个构造器参数时要考虑用构建器
概述：当构造器参数较多时，使用构建器模式可以提高代码可读性。
问题：构建器模式如何解决构造器参数过多的问题？

### 条目3：用私有构造器或者枚举类型强化Singleton属性
概述：使用私有构造器或枚举类型可以确保Singleton模式的正确实现。
问题：为什么枚举类型是实现Singleton的最佳方式？

### 条目4：通过私有构造器强化不可实例化的能力
概述：私有构造器可以防止类被实例化，适用于工具类。
问题：如何确保一个工具类不会被实例化？

### 条目5：避免创建不必要的对象
概述：重用对象可以减少内存开销，提高性能。
问题：在什么情况下应该重用对象而不是创建新对象？

### 条目6：消除过期的对象引用
概述：及时清理不再使用的对象引用可以防止内存泄漏。
问题：如何识别和消除过期的对象引用？

### 条目7：避免使用终结方法
概述：终结方法不可靠且影响性能，应该避免使用。
问题：为什么终结方法不是资源清理的可靠方式？

## 对于所有对象都通用的方法
### 条目8：覆盖equals时请遵守通用约定
概述：正确覆盖equals方法对于对象比较至关重要。
问题：覆盖equals方法时需要遵循哪些约定？

### 条目9：覆盖equals时总要覆盖hashCode
概述：equals和hashCode必须同时覆盖，以维护对象的一致性。
问题：为什么覆盖equals时必须同时覆盖hashCode？

### 条目10：始终要覆盖toString
概述：toString方法可以提供对象的可读性表示。
问题：如何编写一个有效的toString方法？

### 条目11：谨慎地覆盖clone
概述：clone方法容易出错，需要谨慎使用。
问题：实现clone方法时需要注意哪些问题？

### 条目12：考虑实现Comparable接口
概述：实现Comparable接口可以使对象支持自然排序。
问题：实现Comparable接口时需要遵循哪些规则？

## 类和接口
### 条目13：使类和成员的可访问性最小化
概述：通过最小化访问权限来提高封装性和安全性。
问题：如何确定类成员的适当访问级别？

### 条目14：在公有类中使用访问方法而非公有域
概述：使用getter和setter方法可以更好地控制字段访问。
问题：为什么直接暴露公有字段是不好的实践？

### 条目15：使可变性最小化
概述：不可变类更安全、更易于维护。
问题：如何设计一个不可变类？

### 条目16：复合优先于继承
概述：组合比继承更灵活，降低了类之间的耦合。
问题：在什么情况下应该选择组合而不是继承？

### 条目17：要么为继承而设计，并提供文档说明，要么就禁止继承
概述：设计可继承的类需要特别小心，否则应该禁止继承。
问题：设计可继承类时需要注意哪些方面？

### 条目18：接口优于抽象类
概述：接口比抽象类更灵活，支持多重继承。
问题：在什么情况下应该选择接口而不是抽象类？

### 条目19：接口只用于定义类型
概述：接口应该只用于定义类型，而不是常量容器。
问题：为什么不应该使用接口来定义常量？

### 条目20：类层次优于标签类
概述：使用类层次结构比标签类更清晰、更灵活。
问题：标签类存在哪些问题？

### 条目21：用函数对象表示策略
概述：使用函数对象可以实现灵活的策略模式。
问题：如何有效地使用函数对象？

### 条目22：优先考虑静态成员类
概述：静态成员类比非静态成员类更独立、更高效。
问题：在什么情况下应该使用静态成员类？

## 泛型
### 条目23：请不要在新代码中使用原生态类型
概述：使用泛型可以提高类型安全性，避免运行时错误。
问题：为什么应该避免使用原生态类型？

### 条目24：消除非受检警告
概述：消除所有非受检警告可以使代码更安全、更健壮。
问题：如何正确处理非受检警告？

### 条目25：列表优先于数组
概述：列表比数组更安全、更灵活，特别是在泛型中。
问题：为什么在泛型中列表比数组更合适？

### 条目26：优先考虑泛型
概述：使用泛型可以提高代码的可读性和安全性。
问题：如何有效地使用泛型？

### 条目27：优先考虑泛型方法
概述：泛型方法可以使方法更灵活、更安全。
问题：如何设计一个有效的泛型方法？

### 条目28：利用有限制通配符来提升API的灵活性
概述：有限制通配符可以使API更灵活，同时保持类型安全。
问题：如何使用有限制通配符来改进API设计？

### 条目29：优先考虑类型安全的异构容器
概述：类型安全的异构容器可以在保持类型安全的同时存储不同类型的对象。
问题：如何设计一个类型安全的异构容器？

## 枚举和注解
### 条目30：用enum代替int常量
概述：枚举类型比int常量更安全、更易读。
问题：为什么枚举类型优于int常量？

### 条目31：用实例域代替序数
概述：使用实例域比依赖枚举的序数更安全、更灵活。
问题：为什么不应该依赖枚举的序数？

### 条目32：用EnumSet代替位域
概述：EnumSet比位域更安全、更易读。
问题：在什么情况下应该使用EnumSet？

### 条目33：用EnumMap代替序数索引
概述：EnumMap比使用序数索引的数组更安全、更高效。
问题：为什么EnumMap优于序数索引的数组？

### 条目34：用接口模拟可伸缩的枚举
概述：使用接口可以模拟可扩展的枚举类型。
问题：如何实现可扩展的枚举类型？

### 条目35：注解优先于命名模式
概述：注解比命名模式更安全、更灵活。
问题：为什么注解优于命名模式？

### 条目36：坚持使用Override注解
概述：使用@Override注解可以防止意外的重写错误。
问题：为什么应该始终使用@Override注解？

### 条目37：用标记接口定义类型
概述：标记接口可以定义类型，而标记注解不能。
问题：在什么情况下应该使用标记接口？

## 方法
### 条目38：检查参数的有效性
概述：在方法开始处检查参数有效性可以防止错误传播。
问题：如何有效地检查方法参数的有效性？

### 条目39：必要时进行保护性拷贝
概述：保护性拷贝可以防止外部修改影响对象状态。
问题：在什么情况下应该进行保护性拷贝？

### 条目40：谨慎设计方法签名
概述：良好的方法签名设计可以提高API的可用性。
问题：设计方法签名时需要注意哪些方面？

### 条目41：慎用重载
概述：重载方法容易引起混淆，应该谨慎使用。
问题：为什么应该谨慎使用方法重载？

### 条目42：慎用可变参数
概述：可变参数虽然方便，但可能影响性能。
问题：在什么情况下应该使用可变参数？

### 条目43：返回零长度的数组或者集合，而不是null
概述：返回空集合比返回null更安全、更方便。
问题：为什么不应该返回null来表示空集合？

### 条目44：为所有导出的API元素编写文档注释
概述：良好的文档注释可以提高API的可用性。
问题：编写文档注释时需要注意哪些方面？

## 通用程序设计
### 条目45：将局部变量的作用域最小化
概述：最小化局部变量的作用域可以提高代码的可读性和安全性。
问题：如何有效地最小化局部变量的作用域？

### 条目46：for-each循环优先于传统的for循环
概述：for-each循环更简洁、更安全。
问题：为什么for-each循环优于传统for循环？

### 条目47：了解和使用类库
概述：使用标准类库可以提高代码质量和开发效率。
问题：为什么应该优先使用标准类库？

### 条目48：如果需要精确的答案，请避免使用float和double
概述：float和double不适合需要精确结果的场景。
问题：在什么情况下应该避免使用float和double？

### 条目49：基本类型优先于装箱基本类型
概述：基本类型比装箱基本类型更高效。
问题：在什么情况下应该使用基本类型而不是装箱基本类型？

### 条目50：如果其他类型更适合，则尽量避免使用字符串
概述：字符串不是所有问题的通用解决方案。
问题：在什么情况下应该避免使用字符串？

### 条目51：当心字符串连接的性能
概述：字符串连接可能影响性能，特别是在循环中。
问题：如何优化字符串连接的性能？

### 条目52：通过接口引用对象
概述：通过接口引用对象可以使代码更灵活。
问题：为什么应该通过接口引用对象？

### 条目53：接口优先于反射
概述：接口比反射更安全、更高效。
问题：在什么情况下应该使用接口而不是反射？

### 条目54：谨慎地使用本地方法
概述：本地方法可能影响可移植性和安全性。
问题：在什么情况下应该使用本地方法？

### 条目55：谨慎地进行优化
概述：过早优化可能导致代码复杂化。
问题：进行优化时需要注意哪些原则？

### 条目56：遵守普遍接受的命名惯例
概述：遵循命名惯例可以提高代码的可读性。
问题：Java中有哪些重要的命名惯例？

## 异常
### 条目57：只针对异常的情况才使用异常
概述：异常不应该用于控制正常程序流程。
问题：为什么不应该使用异常来控制程序流程？

### 条目58：对可恢复的情况使用受检异常，对编程错误使用运行时异常
概述：正确选择异常类型可以提高代码质量。
问题：如何选择使用受检异常和运行时异常？

### 条目59：避免不必要地使用受检异常
概述：过度使用受检异常可能影响API的可用性。
问题：在什么情况下应该避免使用受检异常？

### 条目60：优先使用标准的异常
概述：使用标准异常可以提高代码的可读性。
问题：为什么应该优先使用标准异常？

### 条目61：抛出与抽象相对应的异常
概述：异常应该与抽象层次相匹配。
问题：如何设计异常层次结构？

### 条目62：每个方法抛出的所有异常都要建立文档
概述：良好的异常文档可以提高API的可用性。
问题：如何有效地记录方法抛出的异常？

### 条目63：在细节消息中包含失败-捕获信息
概述：异常消息应该包含有助于诊断问题的信息。
问题：如何编写有效的异常消息？

### 条目64：努力使失败保持原子性
概述：保持操作的原子性可以提高程序的健壮性。
问题：如何实现操作的原子性？

### 条目65：不要忽略异常
概述：忽略异常可能导致难以诊断的问题。
问题：正确处理异常的最佳实践是什么？

## 并发
### 条目66：同步访问共享的可变数据
概述：正确同步可以防止数据竞争和内存可见性问题。
问题：如何正确地同步共享数据的访问？

### 条目67：避免过度同步
概述：过度同步可能导致性能问题和死锁。
问题：如何避免过度同步？

### 条目68：executor和task优先于线程
概述：使用executor框架比直接使用线程更安全、更灵活。
问题：为什么应该使用executor而不是直接创建线程？

### 条目69：并发工具优先于wait和notify
概述：并发工具比wait和notify更安全、更易用。
问题：在什么情况下应该使用并发工具？

### 条目70：线程安全性的文档化
概述：明确记录类的线程安全性可以帮助正确使用。
问题：如何正确地记录类的线程安全性？

### 条目71：慎用延迟初始化
概述：延迟初始化可能影响性能和线程安全性。
问题：在什么情况下应该使用延迟初始化？

### 条目72：不要依赖于线程调度器
概述：依赖线程调度器可能导致不可靠的行为。
问题：为什么不应该依赖线程调度器？

### 条目73：避免使用线程组
概述：线程组已经过时，应该避免使用。
问题：为什么不应该使用线程组？

## 序列化
### 条目74：谨慎地实现Serializable接口
概述：实现Serializable接口可能带来安全性和兼容性问题。
问题：实现Serializable接口时需要注意哪些问题？

### 条目75：考虑使用自定义的序列化形式
概述：自定义序列化形式可以提高性能和灵活性。
问题：在什么情况下应该使用自定义序列化形式？

### 条目76：保护性地编写readObject方法
概述：保护性地编写readObject方法可以防止反序列化攻击。
问题：如何安全地实现readObject方法？

### 条目77：对于实例控制，枚举类型优先于readResolve
概述：使用枚举类型比readResolve方法更安全。
问题：为什么枚举类型优于readResolve方法？

### 条目78：考虑用序列化代理代替序列化实例
概述：序列化代理模式可以提高序列化的安全性和灵活性。
问题：如何实现序列化代理模式？


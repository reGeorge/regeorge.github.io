[{"title":"读书笔记收集","date":"2025-01-01T12:32:18.000Z","path":"2025/01/01/16_读书笔记收集/","text":"待阅读清单已阅读清单 《蛤蟆先生去看心理医生》 《心流》 《牧羊少年奇幻之旅》 《悉达多》 《人类简史》 《曾国藩传》 《乔布斯传》 《小王子》 《邓小平时代》 《易中天品三国》 《乒乓球有意思》 《失落的卫星》 《纳瓦尔宝典》 《置身事内》 《李光耀观天下》 《为什么精英都是时间控》 《心流》读书笔记 心流的核心要素 明确的目标和即时反馈 挑战与能力的平衡 全神贯注的状态 进入心流的最佳条件 选择”擅长但不精通”的领域 将大目标拆解成小任务 建立清晰的任务闭环 保持正向反馈 个人实践心得 从乒乓球运动的经验来看，面对挑战时的态度至关重要。选择接受挑战还是逃避，会带来完全不同的结局。真正的技能提升需要： 从理论上改变认知 克服心理上的惧怕 达到身心的放松 通过正确练习形成肌肉记忆 获得正向心理反馈 心流体验在不同领域的对比 运动领域（以乒乓球为例）： 即时反馈明确 对手水平匹配时更容易进入状态 环境单纯，易于保持专注 工作领域（以编程为例）： 后端开发更容易进入心流： 微服务设计自带任务拆解特性 清晰的模块定位 明确的全局作用 前端开发的挑战： 所见即所得的即时压力 频繁的需求调整 调试过程易产生挫败感 心态建设 接受不完美 敢于重新开始 避免完美主义陷阱 保持持续学习的态度"},{"title":"工具类项目需求文档","date":"2024-12-31T12:32:18.000Z","path":"2024/12/31/17_工具类项目需求文档/","text":"工具类项目需求文档一、项目概述开发一个集成常用功能的工具类项目，展示各种技术栈的最佳实践。该项目旨在提供一个完整的企业级应用开发框架，包含常用功能模块的标准实现。 二、功能需求1. 基础CRUD功能 用户管理模块 用户信息的增删改查 用户登录注册 角色权限管理 部门组织管理 2. 文件处理功能 文件上传下载 大文件断点续传 文件秒传功能 文件存储管理 Excel处理 Excel模板导入 数据导出Excel 大数据量Excel处理 PDF处理 PDF生成 PDF模板管理 PDF水印添加 3. 定时任务模块 定时任务管理 定时数据清理 定时报表生成 任务执行状态监控 任务配置 CRON表达式配置 任务参数设置 任务执行日志 4. 消息处理模块 消息管理 消息发送与消费 消息重试机制 死信队列处理 消息监控 消息积压监控 消息处理统计 异常消息处理 5. 异步任务处理 任务执行 异步任务执行 并发任务控制 任务进度跟踪 任务管理 任务优先级 任务超时处理 任务结果回调 6. 系统监控 日志管理 操作日志记录 异常日志记录 日志查询分析 性能监控 系统资源监控 接口响应时间 JVM监控 统计分析 API调用统计 用户行为分析 业务指标统计 三、技术栈选型1. 基础框架 Spring Boot (应用框架) Spring Cloud (微服务框架) Maven (项目管理) 2. 数据存储 MySQL (关系型数据库) MongoDB (文档存储) Redis (缓存) 3. 消息队列 RabbitMQ (消息中间件) Kafka (日志收集) 4. 任务调度 XXL-Job (分布式任务调度) Quartz (定时任务) 5. 其他工具 EasyExcel (Excel处理) iText (PDF处理) MinIO (对象存储) 四、项目结构1234567891011project-root/├── common/ # 公共模块│ ├── common-core/ # 核心工具│ ├── common-redis/ # Redis工具│ └── common-log/ # 日志工具├── system/ # 系统模块│ ├── sys-api/ # 接口定义│ └── sys-service/ # 服务实现├── message/ # 消息模块├── task/ # 任务模块└── monitor/ # 监控模块 五、技术实现要点1. 数据库设计示例12345678910-- 用户表CREATE TABLE sys_user ( id BIGINT PRIMARY KEY, username VARCHAR(50) NOT NULL, password VARCHAR(100) NOT NULL, email VARCHAR(100), status TINYINT, create_time DATETIME, update_time DATETIME); 2. 核心配置示例12345678spring: datasource: url: jdbc:mysql://localhost:3306/demo username: root password: root redis: host: localhost port: 6379 3. 关键代码实现示例123456789101112@Servicepublic class UserServiceImpl implements UserService &#123; @Autowired private UserMapper userMapper; @Override public UserDTO createUser(UserCreateReq req) &#123; // 参数校验 // 业务处理 // 返回结果 &#125;&#125; 六、项目实施计划第一阶段：基础框架搭建 (2周) [ ] 项目结构创建 [ ] 基础配置完成 [ ] 数据库设计 第二阶段：核心功能开发 (4周) [ ] 用户管理模块 [ ] 文件处理功能 [ ] 基础CRUD实现 第三阶段：高级特性实现 (3周) [ ] 消息队列集成 [ ] 定时任务开发 [ ] 异步处理实现 第四阶段：系统优化 (3周) [ ] 性能优化 [ ] 单元测试 [ ] 文档完善 七、注意事项1. 代码规范 遵循阿里巴巴Java开发规范 统一的命名规范 完善的注释文档 2. 性能考虑 合理使用缓存 数据库索引优化 并发控制 连接池管理 大数据量处理 3. 安全考虑 数据加密传输 敏感信息加密 权限精细控制 SQL注入防护 XSS防护 CSRF防护 4. 可维护性 模块化设计 接口版本控制 统一异常处理 统一响应格式 完善的日志记录 八、项目验收标准 功能完整性 所有功能模块测试通过 接口文档完善 测试用例覆盖率&gt;80% 性能指标 接口响应时间&lt;500ms 并发用户数&gt;1000 CPU使用率&lt;70% 代码质量 代码规范遵循度&gt;90% 代码重复率&lt;5% 测试覆盖率&gt;80%"},{"title":"开发相关内容记录","date":"2023-01-01T12:32:18.000Z","path":"2023/01/01/15_开发相关内容记录/","text":"sql 优化https://www.51cto.com/article/623584.html MySQL索引学习https://juejin.cn/post/7047433474264793095 redis 详解https://mp.weixin.qq.com/s/kILz0SBtOpGTS8fZgsUfcQ"},{"title":"sublime插件安装","date":"2020-10-07T16:18:18.000Z","path":"2020/10/08/13_sublimetext插件安装/","text":"如何安装插件详见：https://packagecontrol.io/installationOmniMarkupPreviwer实时在浏览器中预览markdown。快捷键如下：Ctrl+Alt+O: Preview Markup in Browser.Ctrl+Alt+X: Export Markup as HTML.Ctrl+Alt+C: Copy Markup as HTML TableEditor 操作 快捷键 备注 启用 ctrl + shift + p Table Editor: Enable for current syntax or view 禁用 ctrl + shift + p Table Editor: Disable for current syntax or view 快速建表 ctrl + k, Enter 要先输入表的第一行 跳转到下一列的单元格 Tab shift + Tab跳转到上一个单元格 跳转到下一行的单元格 Enter 添加一列 alt + shift + 右 在光标所在列左侧插入一列 删除一列 alt + shift + 左 删除光标所在列 交换列位置 alt + 左或右 将光标所在列和左或右侧列交换位置 添加一行 alt + shift + 下 在光标所在行上方插入一行 删除一行 alt + shift + 上 删除光标所在行 交换行位置 alt + 左或右 将光标所在行和上或下侧行交换位置 参考：https://www.jianshu.com/p/aa30cc25c91bhttps://segmentfault.com/a/1190000007935021"},{"title":"客户端测试方案的设计思路","date":"2020-08-31T12:32:18.000Z","path":"2020/08/31/12_测试方案的设计思路/","text":"5W1H原则在任何场景下，组织一场活动也好，制定一个商业计划书也好，5W1H原则都是需要适用的，自然在测试方案的制定上也能够适用。 how：如何去测？用什么资源？依据什么？工具如何选型、案例要执行到什么粒度。 why：为什么要实现这个功能，背景和目的是什么，能给用户或公司带来多大的价值。 what：我需要做什么？任务的目的是什么？ when：项目周期多长，开发时间和提交测试时间是什么时候？什么时候需要给用户？测试周期需多长？ who：项目各个环节的直接责任人、干系人是谁？谁来主导负责？需要多少人力来参与？ where：相关资源的位置和路径，版本、文档。 测试方案对应的需要呈现以上6个方面的问题： why-需求背景、需求内容 where-资源文件归档路径 what-测试的范围 when-测试的周期 who-参与的人员 how-测试的策略 测试设计需要考虑的角度 测试设计需要考虑的角度 功能测试 页面校验 性能指标 异常 功能交互 容限测试 极限 可靠性 国际化 可维护 测试设计需要考虑的影响因素 影响因子 空间状态 云储存空间 本地存储空间 账号状态 AT/ST失效 退出账号 销户 网络状态 网络类型 网络切换 网络质量 服务器状态 密钥服务 域名解析服务 数据库服务 鉴权服务 存储平台 负载平衡 用户操作 重试 连续操作 反复取消/重试 反复暂停/重试 失败/重试 缓存 进程 本地数据库清理 权限修改 时间修改"},{"title":"测试工作的一些总结","date":"2019-07-07T12:32:18.000Z","path":"2019/07/07/14_测试工作的一些总结/","text":"手工测试测试流程规范 产品从立项到发布要经历的流程 立项流程：收集需求（用户、销售、领导等）-&gt;立项（产品经理）-&gt;决策（领导） 设计阶段：需求澄清（产品经理）-&gt;产品设计（UI、架构）-&gt;开发story-&gt;测试方案 开发&amp;转测：进度把控-风险评估 客户验收：结项 测试的职责 输出测试设计和测试用例并由相关人员一起评审（BA，开发，项目经理，测试） 执行测试用例 缺陷跟踪 输出测试报告、测试总结等 测试人员需要掌握的技能 产品从立项到发布的各个流程中，测试需要关注的地方 立项流程中，收集需求这个环节，测试在执行用例期间遇到非bug类的体验问题要本地记录，并汇总反馈给产品经理 设计阶段的评审环节，测试要多从用户体验的角度提出自己的观点和疑问（测试比开发更接近用户，比销售更熟悉产品的实现） 测试方案、测试用例、测试执行、缺陷跟踪是测试的核心职责 测试方案要覆盖全面（测试目的、测试准备、测试分工、测试范围、测试风险） 测试用例要按照功能测试设计将操作步骤、检查点逐一细化 测试执行要覆盖到测试用例的每一个测试步骤和检查点 缺陷跟踪要在回归问题场景的基础上，弄清bug的根因和修改方案，回归测试要考虑到是否需要补充测试方案和测试用例 参考：怎样制定一个合格的测试方案 自动化测试 常见的自动化测试框架 Appium和Selenium了解 开源的自动化框架上手 自动化脚本编写语言 java和python 自动化构建的思路 从脚本到aw，再到框架 自动构建任务，远程执行 测试报告的生成 从手工用例到自动化用例转化的注意点 自动化用例覆盖范围的评审 自动化用例执行失败用例的定位 服务端压测怎么做https://zingphoy.github.io/2020/04/26/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%8E%8B%E6%B5%8B%E6%80%8E%E4%B9%88%E5%81%9A/ 关于兼容性测试兼容性测试做筛选时，基于的不是整体市场份额，而是线上埋点分析得来的用户机型分布。 关于测试的一些想法我们要回归到测试的本质上面来，测试是干什么的？这个职业存在是为了解决什么的？其实，你停下来仔细想想，无外乎在做的就是两个方面，提升质量和增加效率，对吧？那你有没有仔细想过，这两个方面怎么来提升？ 看到一个个很好的建议： 1、要学会数据分析，通过数据分析来发现问题，比方说缺陷分布吧，这些缺陷覆盖了哪些功能模块？覆盖了哪些业务？发生在什么时间段？是哪些测试用例发现的？这些测试用例有没有什么共通点？是偶然发生的？等等，当你数据分析的越完备的时候，你就能发现问题的本质是什么，你就能提高你自己的个人能力 2、要经常停下来对自己进行复盘，对你自己的能力进行总结，写出来、画出来、讲出来，你能清晰的知道你强在哪儿、差在哪儿 3、增加效率的方式有很多很多，哪怕一个命令行、一个小脚本，都可以增加效率，不要深陷其中 4、测试不仅仅是点点点、或者会用某个工具、或者写几行代码，更多的是，你要能分析问题、发现问题、定位问题，如果你测试一个系统，对他的业务架构、技术架构、部署架构、数据架构等等都不了解，那我不认为你是一个合格的测试"},{"title":"让你的hexo支持mermaid","date":"2019-05-26T08:56:24.000Z","path":"2019/05/26/11_让你的Hexo支持mermaid/","text":"mermaid配置方法Mermaid是一个用于生成流程图、时序图等图表的JavaScript库。要在Hexo中使用它,需要以下步骤: npm安装mermaid渲染插件: 1npm install hexo-filter-mermaid-diagrams --save 在Hexo博客的根目录下,修改_config.yml文件,添加以下配置: 123mermaid: enable: true theme: default 在需要插入图表的Markdown文件中,使用Mermaid语法插入图表。例如: graph TD; A-->B; A-->C; B-->D; C-->D; 参考文章： https://www.liuyude.com/How_to_make_your_HEXO_blog_support_handwriting_flowchart.html https://github.com/webappdevelp/hexo-filter-mermaid-diagrams hexo绘制脑图参考文章： https://qsli.github.io/2017/01/01/markdown-mindmap/ https://github.com/HunterXuan/hexo-simple-mindmap 配置完成后，使用mermaid语法流程图graph TD; A-->B; A-->C; B-->D; C-->D; 时序图sequenceDiagram participant Alice participant Bob Alice->John: Hello John, how are you? loop Healthcheck John->John: Fight against hypochondria end Note right of John: Rational thoughts prevail... John-->Alice: Great! John->Bob: How about you? Bob-->John: Jolly good! 甘特图gantt dateFormat YYYY-MM-DD title Adding GANTT diagram functionality to mermaid section A section Completed task :done, des1, 2014-01-06,2014-01-08 Active task :active, des2, 2014-01-09, 3d Future task : des3, after des2, 5d Future task2 : des4, after des3, 5d section Critical tasks Completed task in the critical line :crit, done, 2014-01-06,24h Implement parser and jison :crit, done, after des1, 2d Create tests for parser :crit, active, 3d Future task in critical line :crit, 5d Create tests for renderer :2d Add to mermaid :1d 脑图 在 Hexo 中使用思维导图 前言 操作指南 准备需要的文件 为主题添加 CSS/JS 文件 使用方法"},{"title":"安卓客户端取日志脚本","date":"2019-04-01T12:32:18.000Z","path":"2019/04/01/10_安卓客户端取日志脚本/","text":"安卓客户端取日志脚本：8ii8i i 1234567891011121314151617181920212223242526272829303132333435363738394041@echo off::初始化脚本:startclsecho ****************************************echo [请输入：0] 退出echo [请输入：1] 获取applogecho [请输入：2] 清理applogecho [直接输入回车] 执行默认操作echo ****************************************set FOLDER=%~dp0set TIMESTAMP=%date:~0,4%%date:~5,2%%date:~8,2%_%time:~0,2%%time:~3,2%%time:~6,2%set /p opt=请输入:if &quot;%opt%&quot;==&quot;0&quot; goto exitif &quot;%opt%&quot;==&quot;1&quot; goto get_logif &quot;%opt%&quot;==&quot;&quot; goto default:defaultecho 执行默认操作echo 我啥也没干pausegoto start:get_logecho opt=%opt%echo 获取applogecho 目标路径为 %FOLDER%%TIMESTAMP%::adb pull applog路径 目标路径pausegoto start:clean_logecho opt=%opt%echo 清理applogadb remount::adb shell rm -r xxxpausegoto start"},{"title":"ADB常用命令","date":"2018-07-01T12:32:18.000Z","path":"2018/07/01/09_ADB常用命令/","text":"adb 命令 含义 adb shell adb shell “dumpsys window \\ grep mCurrentFocus” 获取应用包名（打开应用） adb shell pm path 包名 获取应用安装路径 adb shell “pm dump 包名 获取应用版本号 adb shell “cat /system/build.prop 获取手机系统信息（ CPU，厂商名称等） adb shell getprop ro.build.version.release 获取手机系统版本 adb shell getprop ro.build.version.sdk 获取手机系统api版本 adb -d shell getprop ro.product.model 获取手机设备型号 adb -d shell getprop ro.product.brand 获取手机厂商名称 adb shell getprop ro.serialno 获取手机的序列号 adb shell dumpsys iphonesubinfo 获取手机的IMEI adb shell cat /sys/class/net/wlan/address 获取手机mac地址 adb shell cat /proc/meminfo 获取手机内存信息 adb shell df 获取手机存储信息 adb shell df /mnt/shell/emulated 获取手机内部存储信息： adb shell df /storage/sdcard 获取sdcard存储信息： adb shell “dumpsys window 获取手机分辨率 adb shell wm density 获取手机物理密度 adb shell “dumpsys window 获取当前界面对应的活动和包名 待刷新"},{"title":"使用selenium+wget实现自动下载图片","date":"2018-03-05T15:04:42.000Z","path":"2018/03/05/08_使用selenium-wget实现自动下载图片/","text":"操作步骤unsplash.com是一个免费下载高清图片的网站，我们可以使用web自动化工具selenium来批量获取该网站主页上提供的海量图片下载链接，并使用强大的多线程下载工具wget下载这些图片。 另外，selenium需要配合chromedriver.exe来操控谷歌浏览器，我们可以通过搜索下载对应浏览器版本的chromedriver.exe 环境安装 selenium wget pip install selenium pip install wget python脚本from selenium import webdriver import wget import os import time import subprocess def mkdir(path): # 去除首位空格 path=path.strip() # 去除尾部 \\ 符号 path=path.rstrip(&quot;\\\\&quot;) # 判断路径是否存在 # 存在 True # 不存在 False isExists=os.path.exists(path) # 判断结果 if not isExists: # 如果不存在则创建目录 print (&apos;%s创建成功&apos;%path) # 创建目录操作函数 os.makedirs(path) return True else: # 如果目录存在则不创建，并提示目录已存在 print (&apos;%s目录已存在&apos;%path) return False def download_pic(folderpath=&apos;&apos;,list=[]): i = 1 for url in list: try: # wget.download(url, out=&apos;%s\\\\%d.jpg&apos; %(folderpath,i)) cmd = &apos;C:\\\\Python36\\\\Scripts\\\\wget -O &quot;%s\\\\%d.jpg&quot; &quot;%s&quot;&apos; %(folderpath,i,url) print(cmd) subprocess.Popen(cmd) i += 1 except: print(&apos;skip&apos;) print(&apos;下载成功...&apos;) def craw_url(scroll=&apos;2&apos;,web_url=&apos;&apos;): driver = webdriver.Chrome(&apos;C:\\\\Python36\\\\Lib\\site-packages\\\\chromedriver_binary\\\\chromedriver.exe&apos;) driver.get(web_url) driver.maximize_window() time.sleep(3) urls = [] try: for i in range(1,scroll): pics = driver.find_elements_by_class_name(name=&apos;_2zEKz&apos;) for pic in pics: src = &apos;%s\\n&apos;%pic.get_attribute(name=&apos;src&apos;) src = src.replace(&apos;1000&apos;,&apos;2592&apos;) # print(src) urls.append(src) js=&quot;window.scrollTo(0,document.body.scrollHeight)&quot; driver.execute_script(js) time.sleep(3) print(&quot;循环次数：%d&quot;%i) driver.close() except: driver.close() urls = list(set(urls)) print(&apos;获取图片链接成功...&apos;) return urls if __name__ == &quot;__main__&quot;: download_path = &apos;G:\\\\02_photo\\\\unsplash&apos; url_list=craw_url(scroll=1000,web_url=&apos;https://unsplash.com/&apos;) mkdir(download_path) download_pic(folderpath=download_path,list=url_list) # for url in url_list: # print(url) # try: # f=open(&apos;%s\\\\0_urls.txt&apos;%download_path,&apos;w&apos;) # f.writelines(url_list) # f.close() # except: pass 下载成功"},{"title":"Markdown的使用","date":"2018-02-21T12:32:18.000Z","path":"2018/02/21/07_Markdown的使用/","text":"Markdown的常用方法如下： 1.标题### 三级标题 三级标题2.无序列表123- 列表1- 列表2- 列表2 列表1 列表2 列表2 3.有序列表1231. 列表12. 列表23. 列表3 列表1 列表2 列表3 4.链接[百度](http://www.baidu.com/) 百度 5.图片![](http://img0.ph.126.net/lsmfEETHdhqyL1Yshsk4Ww==/6631563645446087568.jpg) 1&lt;img src=&quot;http://img0.ph.126.net/lsmfEETHdhqyL1Yshsk4Ww==/6631563645446087568.jpg&quot; height = &quot;110&quot; div align=&quot;right&quot;/&gt; 6.引用&gt; *我挥舞着本子和键盘*，**发誓要把这世界写个明明白白**。 我挥舞着本子和键盘，发誓要把这世界写个明明白白。 7.代码引用1`hello world` hello world 123for() &#123;i++;&#125; 123for() &#123; i++;&#125; 8.表格1234|姓名|学号|成绩||----|:----:|----:||张三|35|60||李四|33|59| 姓名 学号 成绩 张三 35 60 李四 33 59 8. 换行 直接用空行来代表换行 或者在行位连续输入2个空格来代表换行"},{"title":"百日囚徒问题","date":"2017-12-27T15:09:37.000Z","path":"2017/12/27/06_百日囚徒问题/","text":"有100个无期徒刑囚徒，被关在100个独立的小房间，互相无法通信。每天会有一个囚徒被随机地抽出来放风，随机就是说可能被抽到多次。放风的地方有一盏灯，囚徒可以打开或者关上，除囚徒外，没有别人会去动这个灯。每个人除非出来防风，是看不到这个灯的。 一天，全体囚徒大会，国王大赦，给大家一个机会：如果某一天，某个囚徒能够明确表示，所有的囚徒都已经被放过风了，而且的确如此，那么所有囚徒释放；如果仍有囚徒未被放过风，那么所有的囚徒一起处死！ 囚徒大会后给大家20分钟时间讨论，囚徒们能找到方法么？不考虑什么犯人突然死亡的意外因素。是纯粹的理论题。 思路1、前100天利用灯来互相确认自己的身份（灯初始状态为关闭）： 计数人 首次放风的人不进行任何操作，设第一个二次放风的人为计数人，计数人把灯打开（比如第20天该囚犯第二次去放风，且前面没有人去动过灯，则说明连同他共有19个人是首次放风），则此时生成一个该天数的计数(N-1) 已知囚徒 设剩下的99人中，见到过灯灭状态的人为已知囚徒，因为计数人能通过开灯的日期准确推算出之前的人数 未知囚徒 设从未见过灯灭状态的人为未知囚徒，因为灯打开后，计数人无法获取放风的准确人数 这里有可能出现最好情况：第100天，某首次放风囚徒发现灯为关闭状态，说明前100天均无人2次放风，即每人都是首次放风，可以宣布获救。 2、100天过后，未知囚徒和计数人之间通过灯来传递信息（灯初始状态为打开）： 已知囚徒放风 不进行任何操作 未知囚徒放风 若灯为打开状态，说明通信可用，关灯向计数人传递信息，至此该未知囚徒以后都不再对灯进行操作。 若灯为关闭状态，说明此次通信未结束，不进行任何操作 计数人放风 若灯为关闭状态，计数N+1，并将灯打开，以便下一个未知囚徒传递信息 若灯为打开状态，说明暂时没有未知囚徒发起通信，不进行任何操作 当计数人放风时恰好N=100，则他可以宣布确定所有囚徒都放过风了。 代码import random days = 1 # 天数 light = 0 # 灯 times = [0 for i in range(0,100)] # 每个囚徒放风次数的统计数组 counter = -1 # 计数人 remainer = 100 # 剩余未知人 while 1==1: print(&quot;第%d天: &quot;%days) print(&quot; 剩余未知人: %d&quot;%remainer) # 随机抽选一人放风 P = random.randint(0, 99) # 前100天确认身份 if days &lt;= 100: if light == 0: times[P] += 1 # 灯灭放风有效 if times == 1: pass if times[P] == 2: # 灯灭且第二次放风 counter = P print(&quot; 确定计数人: %d&quot; %counter) light = 1 remainer -= (days-1) # 开灯计数 else: pass # 在灯亮放风无效 if days == 100 and light == 0: # 100天灯仍灭，获救 print(&quot;获救&quot;) break else: # 100天后通过灯通信 if light == 1: times[P] += 1 # 灯亮放风有效 if times[P] == 1: #(未知者)关灯发出信息 light = 0 else: if P == counter: # 灯灭计数人开灯计数 light = 1 remainer -= 1 if remainer == 0: print(&quot; 计数人%d宣布获救&quot; %counter) break days += 1 日志第1天: 剩余未知人: 100 第2天: 剩余未知人: 100 第3天: 剩余未知人: 100 第4天: 剩余未知人: 100 第5天: 剩余未知人: 100 第6天: 剩余未知人: 100 第7天: 剩余未知人: 100 确定计数人: 53 第8天: 剩余未知人: 94 第9天: 剩余未知人: 94 ······ 第9538天: 剩余未知人: 1 第9539天: 剩余未知人: 1 第9540天: 剩余未知人: 1 第9541天: 剩余未知人: 1 计数人53宣布获救"},{"title":"基于android实现一个简单的备忘录app","date":"2017-05-20T12:13:59.000Z","path":"2017/05/20/05_基于android实现一个简单的备忘录app/","text":"增删查改的实现创建主活动及布局文件 主活动是整个app的入口，还原一下用户的使用场景： 点击新增按钮：进入AddContent活动 点击备忘录列表上的某个Item：进入对应的备忘录的查看界面 布局文件中应该有一个新建备忘录的Button和一个显示备忘录列表的ListView。 在MainActivity中创建对象根据id获取到上述布局实体并添加逻辑。 对Button设置点击监听事件并重写点击方法（跳转到新增备忘录的活动）: newbtn.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Intent i = new Intent(MainActivity.this, AddContent.class); startActivity(i); &#125; ); 对ListView绑定ListViewAdapter用于绘制ListView的每一个Item中的显示内容；另外为ListView的Item设置点击监听事件并重写点击方法（跳转到查看备忘录的活动）： lv.setOnItemClickListener(this); @Override public void onItemClick(AdapterView&lt;?&gt; parent, View view, int position, long id) &#123; cursor = dbReader.query(NotesDB.TABLE_NAME, null, null, null, null, null, null); cursor.moveToPosition(position); Intent j = new Intent(MainActivity.this,ShowContent.class); j.putExtra(NotesDB.ID, cursor.getInt(cursor.getColumnIndex(NotesDB.ID))); j.putExtra(NotesDB.CONTENT, cursor.getString(cursor.getColumnIndex(NotesDB.CONTENT))); j.putExtra(NotesDB.TIME, cursor.getString(cursor.getColumnIndex(NotesDB.TIME))); startActivity(j); &#125; 创建数据库 重写了两个方法，分别是创建数据库和更新数据库。 其中onUpgrade()方法确保app在覆盖安装时不会覆盖原有的数据库。 @Override public void onCreate(SQLiteDatabase db) &#123; db.execSQL(&quot;CREATE TABLE &quot; + TABLE_NAME + &quot;(&quot; + ID +&quot; INTEGER PRIMARY KEY AUTOINCREMENT,&quot; + CONTENT + &quot; TEXT NOT NULL,&quot; + TIME + &quot; TEXT NOT NULL)&quot;);//最后的括号不能忘 &#125; @Override public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) &#123; &#125; 创建添加备忘的活动及布局文件 用户的使用场景： 进入AddContent活动输入文字 点击取消按钮：返回MainActivity界面 点击保存按钮：输入的文字和当前日期时间被存入数据库 布局包括一个输入文字的EditText和两个Button分别用于保存和取消。 在活动中为两个按钮设置点击监听事件重写点击方法： 取消按钮：finish()当前活动；需要注意的是，要想返回的活动是主界面必须在Manifest文件中为主活动添加android:launchMode=&quot;singleTask&quot;的声明。 保存按钮：将EditText中的文字和当前时间用ContentValue对象存入数据库；注意获取当前时间用SimpleDateFormat的format方法来得到Date对象的合适的格式，返回值类型为String。 ContentValue和数据库的写入方法如下： public void addDB() &#123; ContentValues cv = new ContentValues(); cv.put(NotesDB.CONTENT,edtext.getText().toString()); cv.put(NotesDB.TIME, getTime()); dbWriter.insert(NotesDB.TABLE_NAME, null, cv); &#125; private String getTime() &#123; SimpleDateFormat format = new SimpleDateFormat(&quot;yyyy年MM月dd日 HH:mm:ss&quot;); Date date = new Date(); String str = format.format(date); return str; &#125; 创建查看备忘的活动及布局文件 用户的使用场景： 123进入ShowContent活动查看备忘录详细内容（包括存在数据库中的时间）点击返回按钮：返回MainActivity界面；点击删除按钮：删除数据库中的对应记录，并保证主活动中的列表也同步 布局包括一个用来显示文字的EditText和两个Button分别用于返回和删除。 活动中两个按钮的点击监听事件： 返回按钮同新增活动中的取消按钮 删除按钮的onClick方法中的删除数据库记录的代码如下： 1234public void deleteData() &#123; dbWriter.delete(NotesDB.TABLE_NAME, &quot;_id=&quot;+getIntent().getIntExtra(NotesDB.ID, 0), null);&#125; 活动中的EditText是用来显示备忘内容的因此将编辑属性关闭，备忘内容从启动该活动的Intent中获取。 1234s_edtxt.setText(this.getIntent().getStringExtra(NotesDB.CONTENT));s_edtxt. setCursorVisible ( false ) ; s_edtxt.setFocusable(false); s_edtxt.clearFocus(); 创建修改备忘的活动及布局文件 用户的使用场景： 123进入UpdateContent活动修改备忘录详细内容（同时更新存在数据库中的时间）点击返回按钮：返回MainActivity界面；点击保存按钮：输入的文字和当前日期时间覆盖数据库中对应的记录 布局包括EditText和两个Button+活动中为两个按钮设置点击监听事件： 返回按钮同新增活动中的取消按钮 保存按钮同新增按钮中的保存按钮 活动中的EditText除了要显示原有的备忘内容外，还要有可以编辑的属性： 1234u_edtxt.setText(this.getIntent().getStringExtra(NotesDB.CONTENT));u_edtxt. setCursorVisible (true) ;u_edtxt.setFocusable(true);u_edtxt.setSelection(u_edtxt.getText().toString().length()); 在Manifest文件中注册活动：12345678910111213141516171819202122232425262728293031323334353637&lt;application android:allowBackup=&quot;true&quot; android:icon=&quot;@mipmap/ic_note_white&quot; android:label=&quot;@string/app_name&quot; android:supportsRtl=&quot;true&quot; android:theme=&quot;@style/AppTheme.NoActionBar&quot;&gt; &lt;activity android:name=&quot;.activity.MainActivity&quot; android:label=&quot;@string/app_name&quot; android:launchMode=&quot;singleTask&quot; android:screenOrientation=&quot;portrait&quot; android:theme=&quot;@style/AppTheme.NoActionBar&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt; &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;activity android:name=&quot;.activity.AddContent&quot; android:label=&quot;新增日程&quot; android:screenOrientation=&quot;portrait&quot; android:theme=&quot;@style/AppTheme.NoActionBar&quot; android:windowSoftInputMode=&quot;adjustResize&quot;&gt;&lt;/activity&gt; &lt;activity android:name=&quot;.activity.ShowContent&quot; android:label=&quot;查看日程&quot; android:screenOrientation=&quot;portrait&quot; android:theme=&quot;@style/AppTheme.NoActionBar&quot;&gt;&lt;/activity&gt; &lt;activity android:name=&quot;.activity.UpdateContent&quot; android:label=&quot;修改日程&quot; android:screenOrientation=&quot;portrait&quot; android:theme=&quot;@style/AppTheme.NoActionBar&quot; android:windowSoftInputMode=&quot;adjustResize&quot;&gt;&lt;/activity&gt; &lt;/application&gt; 至此，备忘录的增删改查功能已经添加完毕。 云端同步功能实现同步功能概述备忘录的云端同步可以让用户在多个设备间同步数据，并提供数据备份功能。实现云同步需要考虑以下几个方面： 数据存储方案 用户认证 同步策略 冲突处理 推荐的技术方案1. 后端存储选择 LeanCloud (推荐) 提供开箱即用的数据存储 内置用户系统 有完整的Android SDK 免费额度足够个人开发者使用 Firebase (替代方案) Google官方支持 实时数据同步 较完善的离线支持 2. 数据表设计123456789Note &#123; objectId: String // 唯一标识 content: String // 备忘内容 createTime: Date // 创建时间 updateTime: Date // 更新时间 userId: String // 用户ID isDeleted: Boolean // 软删除标记 version: Number // 版本号(用于冲突处理)&#125; 实现步骤 (TodoList)1. 基础配置 [ ] 注册LeanCloud账号并创建应用 [ ] 添加LeanCloud SDK依赖 [ ] 在Application中初始化SDK [ ] 配置AndroidManifest添加所需权限 2. 用户系统 [ ] 实现注册界面 [ ] 实现登录界面 [ ] 实现用户信息存储 [ ] 添加登出功能 3. 数据同步 [ ] 修改本地数据库结构，增加同步相关字段 [ ] 实现数据上传功能 [ ] 实现数据下载功能 [ ] 添加定时同步服务 4. 冲突处理 [ ] 实现版本控制 [ ] 添加冲突检测逻辑 [ ] 实现冲突解决策略 5. 离线支持 [ ] 实现本地缓存 [ ] 添加离线操作队列 [ ] 网络恢复后自动同步 代码示例LeanCloud初始化12345678public class MyApplication extends Application &#123; @Override public void onCreate() &#123; super.onCreate(); // 初始化参数依次为 this, AppId, AppKey AVOSCloud.initialize(this,&quot;your_app_id&quot;,&quot;your_app_key&quot;); &#125;&#125; 数据同步示例12345678910111213141516171819202122public class SyncService &#123; public void syncNote(Note note) &#123; AVObject avNote = new AVObject(&quot;Note&quot;); avNote.put(&quot;content&quot;, note.getContent()); avNote.put(&quot;createTime&quot;, note.getCreateTime()); avNote.put(&quot;updateTime&quot;, new Date()); avNote.put(&quot;userId&quot;, AVUser.getCurrentUser().getObjectId()); avNote.put(&quot;version&quot;, note.getVersion()); avNote.saveInBackground().subscribe(new Observer&lt;AVObject&gt;() &#123; @Override public void onSuccess(AVObject avObject) &#123; // 同步成功处理 &#125; @Override public void onError(Throwable throwable) &#123; // 错误处理 &#125; &#125;); &#125;&#125; 注意事项 数据安全 设置适当的ACL权限 敏感数据加密存储 使用HTTPS传输 性能优化 批量同步而不是单条同步 合理设置同步频率 压缩数据包大小 用户体验 同步状态提示 网络异常处理 后台静默同步 耗电优化 使用WorkManager调度同步任务 根据网络状态调整同步策略 避免频繁同步 后续优化方向 支持多设备同步 添加同步历史记录 实现数据版本回滚 添加同步设置选项 支持选择性同步 参考文档： LeanCloud 文档中心 Android WorkManager Android 数据同步最佳实践"},{"title":"遇到乱码问题的解决方案","date":"2017-03-29T14:25:23.000Z","path":"2017/03/29/04_GBK和UTF-8的区别/","text":"编码的概念 GBK编码：是指中国的中文字符，其它它包含了简体中文与繁体中文字符，另外还有一种字符“gb2312”，这种字符仅能存储简体中文字符。 UTF-8编码：它是一种全国家通过的一种编码，如果你的网站涉及到多个国家的语言，那么建议你选择UTF-8编码。 GBK和UTF8有什么区别？ UTF8编码格式很强大，支持所有国家的语言，正是因为它的强大，才会导致它占用的空间大小要比GBK大，对于网站打开速度而言，也是有一定影响的。 GBK编码格式，它的功能少，仅限于中文字符，当然它所占用的空间大小会随着它的功能而减少，打开网页的速度比较快。 如何在sublime中添加对中文的支持 首先安装Package control工具：在Sublime Text里，按ctrl+`，打开Console，一次性输入如下代码： 1import urllib.request,os; pf = &#x27;Package Control.sublime-package&#x27;; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); open(os.path.join(ipp, pf), &#x27;wb&#x27;).write(urllib.request.urlopen( &#x27;http://sublime.wbond.net/&#x27; + pf.replace(&#x27; &#x27;,&#x27;%20&#x27;)).read()) 然后按ctrl shift p 打开命令行模式：输入Install Package关键字，然后点击自动出现的下拉菜单里的第一项：Package Control: Install Package(回车无效) PS：执行上述步骤不要急，左下角会有一个等于号来回动，看着它也许你会安静点。。 稍等一会，会再次在命令行下弹出一个下拉菜单。输入“ConvertToUTF8”或者“GBK Encoding Support”，选择匹配项。中文字符就可以正常显示了。 Tips： 养成将手敲的代码存为 UTF-8 编码格式的习惯 遇到乱码首先尝试转 UTF-8 切忌一看到乱码先乱删一通，然后气急败坏地把代码文件全删了"},{"title":"冒泡排序算法","date":"2017-03-26T15:56:26.000Z","path":"2017/03/26/03_冒泡排序算法/","text":"(对 n 个数降序)冒泡排序的思路是： 1、最多进行 (n-1) 次排序 2、每次排序将从第一个开始遍历和后一个数比较（确定是否执行交换位置） 值得注意的是本次排序后会产生一个最小数，下次排序可以不用和该数进行比较的判断 关于复杂度的概念还未与其他排序算法比较 代码如下：1234567891011121314151617181920212223242526272829303132public class MyBubbleSort &#123; public static void main(String[] args) &#123; int[] arr = &#123;2,6,3,9,4,5,1,2,5,8&#125;; int len = arr.length; for (int i=0;i&lt;len-1;i++) &#123; for (int j=0;j&lt;len-1-i;j++)//减i的原因是经过i+1次排序后倒数第i+1个数都是确认最小的 &#123; if(arr[j]&lt;arr[j+1]) &#123; int temp = 0; temp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = temp; &#125; &#125; System.out.print(&quot;第&quot;+(i+1)+&quot;次排序结果:&quot;); for(int a = 0; a &lt;len;a++) &#123; System.out.print(arr[a] + &quot;\\t&quot;); &#125; System.out.println(&quot;&quot;); &#125; System.out.print(&quot;最终排序结果为：&quot;); for(int a = 0; a &lt;len;a++) &#123; System.out.print(arr[a] + &quot;\\t&quot;); &#125; System.out.println(&quot;&quot;); &#125;&#125;"},{"title":"git常用命令","date":"2017-01-13T17:21:22.000Z","path":"2017/01/14/02_git常用命令/","text":"创建本地仓库git init.git所在文件夹便是git对应的一个本地仓库 创建本地分支git branch master 查看本地分支git branch 设置远程仓库地址git remote add github git@github.com:regeorge/blog.git 查看已配置的远程仓库git remote 从远程仓库更新到本地分支git pull github master 在未加入缓存区时回滚git checkout -- . 将本文件夹内所有改动加入缓存区git add . 在加入缓存区时回滚git reset HEAD 将暂存区的改动提交到本地仓库git commit -m &quot;add all files&quot; 在提交仓库后回滚git log #查看提交记录（带有唯一标识commitid） git revert %commitid% 将本地分支推送到远程仓库git push github master .gitignore文件中写入不需要同步的文件夹路径hexo deploy 命令在使用hexo搭建博客时，blog目录下有一个.git文件夹，而.deploy_git文件夹内的.git文件夹又对应了另一个仓库,hexo d命令正是将此目录下的仓库推送到远程仓库从而实现更新博客的 FAQ Q1：在github上创建仓库，在本地新建仓库并push产生冲突 A1：先pull后pushgit push -u origin master -f 参考：http://wuchong.me/blog/2014/01/17/use-github-to-manage-hexo-source/ http://blog.csdn.net/shiren1118/article/details/7761203 查看提交历史git log 查看简洁的提交历史git log --oneline 查看文件的修改历史git blame &lt;file&gt; 查看工作目录状态git status 比较工作目录和暂存区的差异git diff 比较暂存区和最后一次提交的差异git diff --cached 创建并切换到新分支git checkout -b &lt;branch_name&gt; 合并分支git merge &lt;branch_name&gt; 删除本地分支git branch -d &lt;branch_name&gt; 删除远程分支git push origin --delete &lt;branch_name&gt; 暂存当前更改以便切换分支git stash 恢复暂存的更改git stash pop 查看所有暂存的更改git stash list 清除所有暂存的更改git stash clear sed 命令示例解析1sed -i &#x27;&#x27; &#x27;s/theme.mermaid.enable/mermaid.enable/g&#x27; themes/yelee/layout/_partial/footer.ejs 命令分解： sed: 流编辑器，用于文本处理 -i &#39;&#39;: -i 表示直接修改文件（in-place） &#39;&#39; 是 macOS 下的特殊语法，表示不创建备份文件 &#39;s/theme.mermaid.enable/mermaid.enable/g&#39;: s/ 表示替换（substitute） theme.mermaid.enable 是要被替换的文本 mermaid.enable 是替换后的文本 g 表示全局替换（global） themes/yelee/layout/_partial/footer.ejs: 目标文件路径 作用：将 footer.ejs 文件中所有的 theme.mermaid.enable 替换为 mermaid.enable"},{"title":"如何搭建个人博客","date":"2017-01-09T14:27:45.000Z","path":"2017/01/09/01_如何搭建个人博客/","text":"搭建个人主页的步骤如下： 先将我们写的文章或者照片生成静态页面(hexo) 并将这些静态页面部署到支持静态页面的服务器(github或coding) 这样我们就可以通过服务器的域名地址访问到自己的博客了(regeorge.github.io) 下面是操作步骤： 准备环境： node.js（npm）的安装 1、hexo 是基于 node.js 来生成页面的 2、node.js 提供了 npm 包管理工具，后面安装 hexo 只需要几行命令 hexo 的安装和初始化 1、完成后可以在本地生成默认的博客页面，并通过浏览器预览效果 2、常用的几条命令如下： hexo n p &apos;文章标题&apos; //新建文章 hexo g //生成页面 hexo s //本地预览 hexo d //提交页面 Hexo 常用部署命令详解 hexo g (hexo generate) 作用：生成静态文件 原理： 读取 source 目录下的文件（主要是 markdown） 根据主题模板将内容渲染成 HTML 生成的静态文件存放在 public 目录 包含 HTML、CSS、JavaScript 等资源文件 hexo s (hexo server) 作用：启动本地预览服务器 原理： 启动一个 Node.js 服务器 默认监听 4000 端口 将 public 目录作为网站根目录 支持实时预览（修改文件后自动更新） hexo d (hexo deploy) 作用：部署网站到远程服务器 原理： 首先将 public 目录下的文件复制到 .deploy_git 目录 在 .deploy_git 目录初始化 Git 仓库（如果不存在） 添加远程仓库（通常是 GitHub Pages） 提交所有文件并推送到远程仓库 hexo s -g 作用：生成静态文件并启动预览服务器 原理： 相当于顺序执行 hexo g 和 hexo s 生成的文件存在内存中，服务器关闭后不保存 用于本地快速预览效果 hexo g -d 作用：生成静态文件并立即部署 原理： 相当于顺序执行 hexo g 和 hexo d 先生成静态文件到 public 目录 然后立即部署到远程服务器 常用于确认内容无误后的发布 git 的安装和配置 1、git是用作版本控制的，也就是在本地生成的博客都是通过git来同步到云端服务器 2、上一条的提交页面命令hexo d其实就是通过git将页面提交到配置文件中填写的github仓库的 github 的注册和配置 1、github 提供了一个静态页面服务功能，这里要做的是在github上创建一个指定名称的仓库来放置本地生成好的博客页面文件 2、同时还需要把这个创建好的仓库地址填写到本地的配置信息中 具体的安装步骤请参考gdutxiaoxu的文章，每一步都非常详细：手把手教你用Hexo+Github 搭建属于自己的博客 配置主题跟着上述参考文章的操作步骤配置好环境后，已经可以在本地预览到生成的博客界面了，按照这种方法生成的页面其实都是一样的，要让自己的博客不一样，一是要时常更新自己的文章，二是自定义页面的样式，网上也提供了很多开源的主题可以配置，非常方便，我推荐的主题有Next，Yilia，Yelee，更多的主题可以百度hexo theme 配置的方法就是将主题通过git pull到博客的theme目录下，然后按照该主题的说明文档（github上的readme.md）进行修改自定义的配置 提交页面假设我们已经上面的参考文章配置好了提交的地址：在博客的根目录的配置文件_config.yml中 # Deployment deploy: type: git repo: github: git@github.com:reGeorge/regeorge.github.io.git,master //github仓库 coding: git@git.coding.net:reGeorge/reGeorge.git,master //coding仓库 branch: master 这里我配置了两个地址，执行hexo d命令时会分别向两个仓库推送本地生成的页面，这样我通过两个域名都可以访问到我的博客（coding国内访问的速度更快） https://regeorge.github.io/ http://regeorge.coding.me/"}]
[{"title":"","date":"2025-01-05T15:30:10.103Z","path":"2025/01/05/20_乒乓球实战技术指南/","text":"乒乓球实战技术指南正手体系打法发球抢攻体系 基础发球 正手位快速下旋发球（靠近球台） 反手位短下旋发球（抢攻准备） 长球发球（直接得分或逼迫对手回球质量） 抢攻技术 第三板快速弧圈球（对方回球较高时） 第三板快带（对方回球较低时） 第三板爆冲（对方回球较软时） 站位要领 发球后快速移动到球台中间偏右位置 保持重心前倾，随时准备移动 注意观察对手站位和准备动作 相持阶段打法 正手位控制 中台弧圈球（基本进攻） 快速侧身抽球（强势进攻） 台内快带（抢攻反击） 步法配合 并步移动（左右移动基础） 跨步抽球（扩大击球范围） 跳步调整（快速回位） 反手体系打法近台快攻体系 基本站位 偏左站位（便于反手控制） 重心略降低（提高稳定性） 手肘保持适当距离（便于快速反应） 技术要点 反手快速推挡（基础技术） 反手快攻（主要得分手段） 反手搓球（变化技术） 战术应用 反手位发球后快攻 台内快速相持 适时结合正手进攻 实战技巧发球技巧 短球发球 球要触网，降低高度 加强旋转变化 注意发球动作相似性 长球发球 突然加快速度 改变落点 结合战术意图 接发球技巧 短球处理 轻推短球（保持主动） 突然搓长（打乱对手节奏） 快速推攻（抢攻机会） 长球处理 快速弧圈球（抢攻为主） 侧身抽球（强势进攻） 稳健推挡（保持相持） 实战训练方法基础训练 多球训练 固定落点移动训练 不固定落点移动训练 发球抢攻专项训练 对打训练 单一技术对打 组合技术对打 实战模拟对打 进阶训练 战术演练 发球后三板战术 接发球后四板战术 相持阶段战术 实战模拟 11分制比赛 特定分数段练习 不同打法对抗 常见问题解决技术问题 发球不稳定 检查抛球高度 保持动作一致 控制触球部位 击球不到位 调整站位距离 检查击球点 加强步法训练 战术问题 无法形成进攻 改善发球质量 提高抢攻意识 加强战术训练 易失误 降低击球力量 提高击球稳定性 选择合适进攻时机"},{"title":"闲聊记录","date":"2025-01-04T16:00:00.000Z","path":"2025/01/05/21_闲聊记录/","text":"要找到最适合自己且团队也需要的事情，然后全力投入去做。自己不适合的要放手给其他适合的人做核心理念解读1. 个人定位的重要性 找准优势：每个人都有自己的长处和短板 适合度优先：不是所有工作都适合自己去做，要找到与自己能力、兴趣最匹配的方向 双向选择：既要符合个人特点，也要满足团队需求 2. 投入的态度 全力以赴：找到合适的事情后，要投入足够的精力和热情 持续深耕：在选定的领域不断精进，形成专业优势 价值创造：通过专注和深入，为团队创造最大价值 3. 放手的智慧 知己知彼：承认自己的局限，认可他人的长处 合理分工：让更适合的人去做更适合的事 团队效能：通过合理分工，提高整体效率 4. 管理的视角 人岗匹配：根据每个人的特点分配合适的工作 扬长避短：发挥每个人的优势，规避短板 整体效益：通过合理分工实现团队整体效能的最大化 如何践行1. 自我认知 能力盘点 列出自己的技术特长和软技能 找出自己最擅长的领域 识别需要提升的短板 兴趣探索 记录工作中最有热情的事情 注意自己投入时不知不觉加班的任务 观察哪些工作让自己感到有成就感 2. 团队需求分析 与领导沟通 了解团队的战略方向 询问最需要人手的领域 讨论可能的发展机会 横向交流 和同事讨论各自的强项 了解团队中的技能空缺 寻找互补合作的机会 3. 循序渐进 小范围尝试 先从小项目开始 在现有工作中逐步调整方向 收集反馈并及时调整 建立反馈机制 定期与领导复盘 请同事给出建议 评估工作成效 4. 主动作为 提出建议 针对团队痛点提出解决方案 主动承担符合自己特长的任务 提出创新性的工作方法 创造价值 将个人专长转化为团队资产 建立个人品牌和影响力 帮助他人提升能力 5. 合理放手 识别界限 明确什么是自己不擅长的领域 承认他人的专业优势 学会说”不”，但要提供建设性建议 有效交接 找到合适的接手人 做好知识传递 保持良好的沟通和支持 6. 持续成长 制定计划 设定清晰的职业目标 规划必要的技能提升路径 保持学习的动力 建立护城河 在自己的专长领域持续深耕 形成不可替代的竞争力 建立个人特色的工作方法 关键要点 保持开放心态：接受变化，愿意尝试 注重沟通：与团队保持良好互动 结果导向：关注实际贡献和价值 长期视角：职业发展是一个持续的过程 兼容性测试做筛选时，基于的不是整体市场份额，而是线上埋点分析得来的用户机型分布两种数据来源的差异 整体市场份额数据 来自市场调研机构（如IDC、Gartner等） 反映整个市场的设备分布情况 包含所有用户群体的使用情况 数据更新周期较长 可能包含非目标用户群体 线上埋点数据 来自实际产品使用数据 只反映你的用户群体的设备分布 数据更新实时 更贴近实际用户场景 为什么会有差异 用户群体差异 产品的目标用户可能集中在特定人群 不同人群的设备选择偏好不同 地域、年龄、消费能力等因素影响 使用场景差异 某些设备可能更适合特定类型的应用 用户在不同场景下使用不同设备 产品特性影响 产品的技术要求可能筛选掉部分设备 营销渠道可能影响用户设备分布 实践建议 数据驱动决策 优先考虑自身用户的设备分布 根据实际使用数据调整兼容性策略 持续监控数据变化 资源优化分配 将测试资源集中在高频使用机型 优先解决影响用户量大的兼容性问题 平衡投入产出比 动态调整策略 定期分析用户设备变化趋势 及时调整兼容性测试范围 预判未来可能的变化"},{"title":"读书笔记收集","date":"2024-12-31T16:00:00.000Z","path":"2025/01/01/16_读书笔记收集/","text":"待阅读清单已阅读清单 《蛤蟆先生去看心理医生》 《心流》 《牧羊少年奇幻之旅》 《悉达多》 《人类简史》 《曾国藩传》 《乔布斯传》 《小王子》 《邓小平时代》 《易中天品三国》 《乒乓球有意思》 《失落的卫星》 《纳瓦尔宝典》 《置身事内》 《李光耀观天下》 《为什么精英都是时间控》 《心流》读书笔记 心流的核心要素 明确的目标和即时反馈 挑战与能力的平衡 全神贯注的状态 进入心流的最佳条件 选择”擅长但不精通”的领域 将大目标拆解成小任务 建立清晰的任务闭环 保持正向反馈 个人实践心得 从乒乓球运动的经验来看，面对挑战时的态度至关重要。选择接受挑战还是逃避，会带来完全不同的结局。真正的技能提升需要： 从理论上改变认知 克服心理上的惧怕 达到身心的放松 通过正确练习形成肌肉记忆 获得正向心理反馈 心流体验在不同领域的对比 运动领域（以乒乓球为例）： 即时反馈明确 对手水平匹配时更容易进入状态 环境单纯，易于保持专注 工作领域（以编程为例）： 后端开发更容易进入心流： 微服务设计自带任务拆解特性 清晰的模块定位 明确的全局作用 前端开发的挑战： 所见即所得的即时压力 频繁的需求调整 调试过程易产生挫败感 心态建设 接受不完美 敢于重新开始 避免完美主义陷阱 保持持续学习的态度 《为什么精英都是时间控》读书笔记（引用自书评，这里记录一下学习用）《为什么精英都是时间控》这本书干货满满，作者是位神经科医学者，很多观点都具有医学根据，很受用。 下面摘录下本书中我的读后心得共勉之 1.专注力（工作效率）×时间=工作量，上午的时间价值是晚上时间价值的4倍，专注性工作选择上午做！提高专注力的小三点：第一是日光浴，第二是有节奏的运动，第三是足够的睡眠。 2.为了维持白天头脑清醒的状态，人每天需要7～9个小时的高质量睡眠。 科学数据表明，睡眠时间不充足的人患上癌症的风险是一般人的6倍，患上脑出血的风险是一般人的4倍，患上心肌梗死的风险是一般人的3倍，患上高血压的风险是一般人的2倍，患上糖尿病的风险是一般人的3倍。一项针对日本男性的调查显示，平时睡眠时间不足6个小时的人，与每天睡7～8个小时的人相比，死亡率要高出2.4倍。 由此可见，缩短睡眠时间，无异于缩短寿命。 3.有氧运动对头脑非常好。在进行有氧运动的时候，头脑会分泌一种名叫BDNF（brain derived neurotrophic factor，脑源性神经营养因子）的物质，BDNF对脑神经的成长发育和正常运转起着至关重要的作用。此外，头脑还会分泌一种叫作多巴胺的神经递质，多巴胺能够提高人的兴致，使人产生幸福感。结果，适度运动之后，不仅能提高人的专注力，就连记忆力、思考能力、工作执行能力等多种脑机能都会得到提高。 4.自我投资，无限成长。学会投资自己的专长，把时间用在帮助自己成长为人生助乐的事情上。 5.多读书，读完以后一定要有输出。 最简单的读书输出法叫作“3点输出法”。就是用3个要点来总结这本书带给您的收获，每一点只需写一行字就够了。用这种方法为一本书写读后感，只需3分钟即可。 6.要早起，人一天专注度最高的时间段是早上6-7点，9点过后，专注力开始下降，下午2点接近最低点！下午4-5点专注力才开始回升，每早起2小时，静心做一件事。 7.早起一定要吃，多咀嚼。晚上睡觉前2小时不要吃东西。 8.上班后的第一件事应该是制作“TO DO清单”，把今天该做的工作，列一个清单。把一天该做的工作列出来之后，再决定工作顺序，即先做哪件事，再做哪件事，即制作一个流程表。 9.利用时间限制术和后有约定工作术克服拖延。“后有约定”工作术，其实就是一种强制性时间限制的工作方法。“后有约定”工作术每天都可以应用在工作中。 10.早晨起床冲个淋浴之后，专注力就达到了高峰，可以开始一上午的工作。中午通过吃午餐，又可以将大脑重启，开启下午的专注工作时间。傍晚适度运动一下，再次重启身心，又可以专注地做你想做的事情。 11.这个世界上最宝贵的东西莫过于时间。所以，我们珍惜自己的时间理所当然，但是，我们应该将心比心，同样尊重、珍惜别人的时间。与别人约定一定不要迟到，珍惜别人的时间也珍惜自己的时间，做一个严格守时的人。脑子里时刻要有“For you”思想，这是一种礼貌，不要丧失别人对自己的信任。 12.“2分钟之内可以完成的工作”一定不要往后拖延，马上就把它解决掉。 13.“一边……一边……”只能使注意力分散，而合理搭配的并行工作，却能让效率显著提高。时间管理达人，通过并行工作的方式一天甚至能创造出好几个小时的额外时间。 14.“痴迷于兴趣爱好之中”其实是锻炼专注力的最好方法。因为真心喜欢，我们才会忘记时间、忘记自我，不觉得辛苦，也只有这样才能发挥出最高的专注力和潜能。 专注力×时间=专注时间。 工作也好，爱好也罢，能够发挥高度专注力的人，拥有更多的专注时间。这样的人不仅工作效率高，工作质量也高。 一流的“趣味人”一定也能成为一流的“工作人”。 15.不知道自己什么时候最快乐的人，就不可能拥有适合自己的“最强放松时间”。因为无论做什么，他都不会感到快乐。 不了解自己快乐瞬间的人，是因为没有竖起接收快乐的天线。 16.每天晚上睡前15分钟我有一个习惯——把今天最快乐的事情记录下来发布在Facebook上。带着快乐的回忆入睡，也会为明天寻找快乐而竖起天线。 17.制作一张玩乐的TO DO清单 有了玩乐的TO DO清单就不同了。只要一有自由时间，就可以立刻按照清单把“最想玩”的事情付诸行动。自由时间就会过得很有意思，也不用浪费时间去思考该玩什么、怎么玩。"},{"title":"通过微信公众号实现自动发布文章","date":"2024-12-31T16:00:00.000Z","path":"2025/01/01/18_公众号实现发布文章/","text":"功能概述实现一个自动化文章发布系统，通过向微信公众号发送消息，自动将内容转换为博客文章并发布到 GitHub 仓库。 主要功能 接收微信公众号消息 自动格式化为博客文章格式 推送到 GitHub 指定仓库的 posts 目录 触发 GitHub Actions 自动构建并部署博客 公众号推送成功的消息 实现流程1. 微信公众号配置 注册个人订阅号 获取开发必需的 AppID 和 AppSecret 配置服务器 URL 和 Token 开启开发者模式 2. 服务器准备 使用免费服务器方案： Railway.app（提供每月免费额度） Heroku（提供免费套餐） Vercel（适合部署 Node.js 应用） Render.com（提供免费套餐） 免费域名和 SSL 方案： 域名：使用 .tk、.ml 等免费顶级域名 SSL 证书：使用 Let’s Encrypt 免费证书 或直接使用平台提供的子域名（如 xxx.vercel.app），自带 HTTPS Web 服务环境： 使用 Flask/Django（Python）或 Express（Node.js）搭建 直接使用平台提供的一键部署功能 3. 消息处理流程 接收微信消息 验证消息发送者身份 提取消息内容并格式化 生成符合博客要求的 Markdown 文件 通过 GitHub API 推送文件 4. 文章格式消息将被转换为以下格式： 123456789---title: 文章标题date: 发送时间categories:博客tags:随笔---正文内容... 注意事项安全性考虑 仅处理指定用户的消息 安全存储各类 Token 定期更新访问凭证 使用限制 仅支持文本消息 第一行作为文章标题 仅支持单一发送者 后续优化方向 支持图片上传 添加文章分类和标签管理 支持文章修改功能 添加发布状态反馈 支持文章预览功能"},{"title":"工具类项目需求文档","date":"2024-12-31T16:00:00.000Z","path":"2025/01/01/17_工具类项目需求文档/","text":"工具类项目需求文档一、项目概述开发一个集成常用功能的工具类项目，展示各种技术栈的最佳实践。该项目旨在提供一个完整的企业级应用开发框架，包含常用功能模块的标准实现。 二、功能需求1. 基础CRUD功能 用户管理模块 用户信息的增删改查 用户登录注册 角色权限管理 部门组织管理 2. 文件处理功能 文件上传下载 大文件断点续传 文件秒传功能 文件存储管理 Excel处理 Excel模板导入 数据导出Excel 大数据量Excel处理 PDF处理 PDF生成 PDF模板管理 PDF水印添加 3. 定时任务模块 定时任务管理 定时数据清理 定时报表生成 任务执行状态监控 任务配置 CRON表达式配置 任务参数设置 任务执行日志 4. 消息处理模块 消息管理 消息发送与消费 消息重试机制 死信队列处理 消息监控 消息积压监控 消息处理统计 异常消息处理 5. 异步任务处理 任务执行 异步任务执行 并发任务控制 任务进度跟踪 任务管理 任务优先级 任务超时处理 任务结果回调 6. 系统监控 日志管理 操作日志记录 异常日志记录 日志查询分析 性能监控 系统资源监控 接口响应时间 JVM监控 统计分析 API调用统计 用户行为分析 业务指标统计 三、技术栈选型1. 基础框架 Spring Boot (应用框架) Spring Cloud (微服务框架) Maven (项目管理) 2. 数据存储 MySQL (关系型数据库) MongoDB (文档存储) Redis (缓存) 3. 消息队列 RabbitMQ (消息中间件) Kafka (日志收集) 4. 任务调度 XXL-Job (分布式任务调度) Quartz (定时任务) 5. 其他工具 EasyExcel (Excel处理) iText (PDF处理) MinIO (对象存储) 四、项目结构1234567891011project-root/├── common/ # 公共模块│ ├── common-core/ # 核心工具│ ├── common-redis/ # Redis工具│ └── common-log/ # 日志工具├── system/ # 系统模块│ ├── sys-api/ # 接口定义│ └── sys-service/ # 服务实现├── message/ # 消息模块├── task/ # 任务模块└── monitor/ # 监控模块 五、技术实现要点1. 数据库设计示例12345678910-- 用户表CREATE TABLE sys_user ( id BIGINT PRIMARY KEY, username VARCHAR(50) NOT NULL, password VARCHAR(100) NOT NULL, email VARCHAR(100), status TINYINT, create_time DATETIME, update_time DATETIME); 2. 核心配置示例12345678spring: datasource: url: jdbc:mysql://localhost:3306/demo username: root password: root redis: host: localhost port: 6379 3. 关键代码实现示例123456789101112@Servicepublic class UserServiceImpl implements UserService &#123; @Autowired private UserMapper userMapper; @Override public UserDTO createUser(UserCreateReq req) &#123; // 参数校验 // 业务处理 // 返回结果 &#125;&#125; 六、项目实施计划第一阶段：基础框架搭建 (2周) [ ] 项目结构创建 [ ] 基础配置完成 [ ] 数据库设计 第二阶段：核心功能开发 (4周) [ ] 用户管理模块 [ ] 文件处理功能 [ ] 基础CRUD实现 第三阶段：高级特性实现 (3周) [ ] 消息队列集成 [ ] 定时任务开发 [ ] 异步处理实现 第四阶段：系统优化 (3周) [ ] 性能优化 [ ] 单元测试 [ ] 文档完善 七、注意事项1. 代码规范 遵循阿里巴巴Java开发规范 统一的命名规范 完善的注释文档 2. 性能考虑 合理使用缓存 数据库索引优化 并发控制 连接池管理 大数据量处理 3. 安全考虑 数据加密传输 敏感信息加密 权限精细控制 SQL注入防护 XSS防护 CSRF防护 4. 可维护性 模块化设计 接口版本控制 统一异常处理 统一响应格式 完善的日志记录 八、项目验收标准 功能完整性 所有功能模块测试通过 接口文档完善 测试用例覆盖率&gt;80% 性能指标 接口响应时间&lt;500ms 并发用户数&gt;1000 CPU使用率&lt;70% 代码质量 代码规范遵循度&gt;90% 代码重复率&lt;5% 测试覆盖率&gt;80%"},{"title":"自动化如何设计和维护才能不成为每日工作的一部分","date":"2024-03-20T16:00:00.000Z","path":"2024/03/21/19_自动化如何设计和维护才能不成为每日工作的一部分/","text":"前言很多时候，我们引入自动化是为了提高效率，但如果设计和维护不当，自动化反而会变成日常工作的负担。本文将探讨如何设计和维护自动化系统，使其真正成为效率工具而不是额外负担。 一、自动化设计的核心原则1. 保持简单性 避免过度工程化 只自动化真正重复且稳定的流程 模块化设计，便于维护和更新 2. 可观测性 完善的日志系统 关键节点的监控告警 清晰的状态展示 3. 容错性 优雅的错误处理机制 自动重试机制 手动介入的接口预留 二、避免自动化陷阱1. 过度自动化 不是所有流程都适合自动化 评估投入产出比 保留必要的人工干预环节 2. 脆弱的依赖 减少外部依赖 做好依赖的版本管理 设计降级方案 3. 维护成本高 文档先行 代码可读性优先 统一的规范和标准 三、可持续的自动化维护策略1. 预防性维护 定期代码审查 及时更新依赖 性能监控和优化 2. 文档驱动 详细的设计文档 操作手册和故障处理指南 变更记录和版本控制 3. 团队协作 知识共享机制 明确的责任分工 持续的技能培训 四、最佳实践建议1. 循序渐进 从小规模开始 逐步扩展和完善 及时总结经验 2. 标准化流程 统一的开发规范 固定的发布流程 规范的审核机制 3. 持续优化 定期评估效果 收集用户反馈 及时调整改进 总结好的自动化应该是”搭建之后就不用太操心”的系统。通过合理的设计和维护策略，我们可以让自动化真正成为提升效率的工具，而不是日常工作的负担。关键在于保持简单、重视可维护性，并建立长期有效的维护机制。 参考资料 《持续交付：发布可靠软件的系统方法》 《SRE：Google运维解密》 《DevOps实践指南》"},{"title":"开发相关内容记录","date":"2023-01-01T12:32:18.000Z","path":"2023/01/01/15_开发相关内容记录/","text":"sql 优化https://www.51cto.com/article/623584.html MySQL索引学习https://juejin.cn/post/7047433474264793095 redis 详解https://mp.weixin.qq.com/s/kILz0SBtOpGTS8fZgsUfcQ"},{"title":"sublime插件安装","date":"2020-10-07T16:18:18.000Z","path":"2020/10/08/13_sublimetext插件安装/","text":"如何安装插件详见：https://packagecontrol.io/installationOmniMarkupPreviwer实时在浏览器中预览markdown。快捷键如下：Ctrl+Alt+O: Preview Markup in Browser.Ctrl+Alt+X: Export Markup as HTML.Ctrl+Alt+C: Copy Markup as HTML TableEditor 操作 快捷键 备注 启用 ctrl + shift + p Table Editor: Enable for current syntax or view 禁用 ctrl + shift + p Table Editor: Disable for current syntax or view 快速建表 ctrl + k, Enter 要先输入表的第一行 跳转到下一列的单元格 Tab shift + Tab跳转到上一个单元格 跳转到下一行的单元格 Enter 添加一列 alt + shift + 右 在光标所在列左侧插入一列 删除一列 alt + shift + 左 删除光标所在列 交换列位置 alt + 左或右 将光标所在列和左或右侧列交换位置 添加一行 alt + shift + 下 在光标所在行上方插入一行 删除一行 alt + shift + 上 删除光标所在行 交换行位置 alt + 左或右 将光标所在行和上或下侧行交换位置 参考：https://www.jianshu.com/p/aa30cc25c91bhttps://segmentfault.com/a/1190000007935021"},{"title":"客户端测试方案的设计思路","date":"2020-08-31T12:32:18.000Z","path":"2020/08/31/12_测试方案的设计思路/","text":"5W1H原则在任何场景下，组织一场活动也好，制定一个商业计划书也好，5W1H原则都是需要适用的，自然在测试方案的制定上也能够适用。 how：如何去测？用什么资源？依据什么？工具如何选型、案例要执行到什么粒度。 why：为什么要实现这个功能，背景和目的是什么，能给用户或公司带来多大的价值。 what：我需要做什么？任务的目的是什么？ when：项目周期多长，开发时间和提交测试时间是什么时候？什么时候需要给用户？测试周期需多长？ who：项目各个环节的直接责任人、干系人是谁？谁来主导负责？需要多少人力来参与？ where：相关资源的位置和路径，版本、文档。 测试方案对应的需要呈现以上6个方面的问题： why-需求背景、需求内容 where-资源文件归档路径 what-测试的范围 when-测试的周期 who-参与的人员 how-测试的策略 测试设计需要考虑的角度 测试设计需要考虑的角度 功能测试 页面校验 性能指标 异常 功能交互 容限测试 极限 可靠性 国际化 可维护 测试设计需要考虑的影响因素 影响因子 空间状态 云储存空间 本地存储空间 账号状态 AT/ST失效 退出账号 销户 网络状态 网络类型 网络切换 网络质量 服务器状态 密钥服务 域名解析服务 数据库服务 鉴权服务 存储平台 负载平衡 用户操作 重试 连续操作 反复取消/重试 反复暂停/重试 失败/重试 缓存 进程 本地数据库清理 权限修改 时间修改"},{"title":"测试工作的一些总结","date":"2019-07-07T12:32:18.000Z","path":"2019/07/07/14_测试工作的一些总结/","text":"手工测试测试流程规范 产品从立项到发布要经历的流程 立项流程：收集需求（用户、销售、领导等）-&gt;立项（产品经理）-&gt;决策（领导） 设计阶段：需求澄清（产品经理）-&gt;产品设计（UI、架构）-&gt;开发story-&gt;测试方案 开发&amp;转测：进度把控-风险评估 客户验收：结项 测试的职责 输出测试设计和测试用例并由相关人员一起评审（BA，开发，项目经理，测试） 执行测试用例 缺陷跟踪 输出测试报告、测试总结等 测试人员需要掌握的技能 产品从立项到发布的各个流程中，测试需要关注的地方 立项流程中，收集需求这个环节，测试在执行用例期间遇到非bug类的体验问题要本地记录，并汇总反馈给产品经理 设计阶段的评审环节，测试要多从用户体验的角度提出自己的观点和疑问（测试比开发更接近用户，比销售更熟悉产品的实现） 测试方案、测试用例、测试执行、缺陷跟踪是测试的核心职责 测试方案要覆盖全面（测试目的、测试准备、测试分工、测试范围、测试风险） 测试用例要按照功能测试设计将操作步骤、检查点逐一细化 测试执行要覆盖到测试用例的每一个测试步骤和检查点 缺陷跟踪要在回归问题场景的基础上，弄清bug的根因和修改方案，回归测试要考虑到是否需要补充测试方案和测试用例 参考：怎样制定一个合格的测试方案 自动化测试 常见的自动化测试框架 Appium和Selenium了解 开源的自动化框架上手 自动化脚本编写语言 java和python 自动化构建的思路 从脚本到aw，再到框架 自动构建任务，远程执行 测试报告的生成 从手工用例到自动化用例转化的注意点 自动化用例覆盖范围的评审 自动化用例执行失败用例的定位 服务端压测怎么做https://zingphoy.github.io/2020/04/26/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%8E%8B%E6%B5%8B%E6%80%8E%E4%B9%88%E5%81%9A/ 关于兼容性测试兼容性测试做筛选时，基于的不是整体市场份额，而是线上埋点分析得来的用户机型分布。 关于测试的一些想法我们要回归到测试的本质上面来，测试是干什么的？这个职业存在是为了解决什么的？其实，你停下来仔细想想，无外乎在做的就是两个方面，提升质量和增加效率，对吧？那你有没有仔细想过，这两个方面怎么来提升？ 看到一个个很好的建议： 1、要学会数据分析，通过数据分析来发现问题，比方说缺陷分布吧，这些缺陷覆盖了哪些功能模块？覆盖了哪些业务？发生在什么时间段？是哪些测试用例发现的？这些测试用例有没有什么共通点？是偶然发生的？等等，当你数据分析的越完备的时候，你就能发现问题的本质是什么，你就能提高你自己的个人能力 2、要经常停下来对自己进行复盘，对你自己的能力进行总结，写出来、画出来、讲出来，你能清晰的知道你强在哪儿、差在哪儿 3、增加效率的方式有很多很多，哪怕一个命令行、一个小脚本，都可以增加效率，不要深陷其中 4、测试不仅仅是点点点、或者会用某个工具、或者写几行代码，更多的是，你要能分析问题、发现问题、定位问题，如果你测试一个系统，对他的业务架构、技术架构、部署架构、数据架构等等都不了解，那我不认为你是一个合格的测试 5、测试的本质是发现问题，而不是解决问题，解决问题是开发的事情，测试的职责是发现问题，并给出解决方案 // … 前面的内容保持不变 … 测试工作的本质思考核心问题测试工作的本质是什么？这个职业存在是为了解决什么问题？ 提升质量 增加效率 1. 测试的本质目标 质量提升 发现并预防缺陷 保证产品可用性 提升用户体验 效率增加 优化测试流程 减少重复工作 加快反馈速度 2. 数据分析能力的重要性缺陷分析维度 功能分布 哪些模块缺陷多发 是否存在模块间关联性 功能覆盖度分析 时间分布 缺陷发现的时间节点 项目周期的关键时间点 修复时间分析 用例效率 高效用例的特征 用例设计的优化方向 测试策略的调整依据 分析方法 数据可视化 趋势分析 根因分析 相关性分析 3. 个人能力复盘复盘维度 技术能力 测试理论基础 自动化测试水平 问题分析能力 业务能力 业务理解深度 需求分析能力 场景设计能力 软技能 沟通协作 项目管理 文档输出 复盘方法 定期总结文档 技能图谱绘制 能力模型对标 4. 效率提升方法工具层面 自动化脚本 效率工具开发 测试框架搭建 流程层面 流程优化 协作模式改进 文档标准化 5. 全面认知系统认知 业务架构 业务流程 业务规则 业务价值 技术架构 系统组件 接口设计 数据流转 部署架构 环境配置 部署策略 监控告警 数据架构 数据模型 数据流向 数据质量 实践建议 建立数据意识 收集关键指标 建立分析模型 形成决策依据 持续学习 技术栈扩展 业务深度理解 工具方法创新 效率工具 从小工具开始 解决实际问题 循序渐进提升 全局视角 理解系统全貌 把握核心架构 关注业务价值"},{"title":"让你的hexo支持mermaid","date":"2019-05-26T08:56:24.000Z","path":"2019/05/26/11_让你的Hexo支持mermaid/","text":"mermaid配置方法Mermaid是一个用于生成流程图、时序图等图表的JavaScript库。要在Hexo中使用它,需要以下步骤: npm安装mermaid渲染插件: 1npm install hexo-filter-mermaid-diagrams --save 在Hexo博客的根目录下,修改_config.yml文件,添加以下配置: 123mermaid: enable: true theme: default 在需要插入图表的Markdown文件中,使用Mermaid语法插入图表。例如: graph TD; A-->B; A-->C; B-->D; C-->D; 参考文章： https://www.liuyude.com/How_to_make_your_HEXO_blog_support_handwriting_flowchart.html https://github.com/webappdevelp/hexo-filter-mermaid-diagrams hexo绘制脑图参考文章： https://qsli.github.io/2017/01/01/markdown-mindmap/ https://github.com/HunterXuan/hexo-simple-mindmap 配置完成后，使用mermaid语法流程图graph TD; A-->B; A-->C; B-->D; C-->D; 时序图sequenceDiagram participant Alice participant Bob Alice->John: Hello John, how are you? loop Healthcheck John->John: Fight against hypochondria end Note right of John: Rational thoughts prevail... John-->Alice: Great! John->Bob: How about you? Bob-->John: Jolly good! 甘特图gantt dateFormat YYYY-MM-DD title Adding GANTT diagram functionality to mermaid section A section Completed task :done, des1, 2014-01-06,2014-01-08 Active task :active, des2, 2014-01-09, 3d Future task : des3, after des2, 5d Future task2 : des4, after des3, 5d section Critical tasks Completed task in the critical line :crit, done, 2014-01-06,24h Implement parser and jison :crit, done, after des1, 2d Create tests for parser :crit, active, 3d Future task in critical line :crit, 5d Create tests for renderer :2d Add to mermaid :1d 脑图 在 Hexo 中使用思维导图 前言 操作指南 准备需要的文件 为主题添加 CSS/JS 文件 使用方法"},{"title":"安卓客户端取日志脚本","date":"2019-04-01T12:32:18.000Z","path":"2019/04/01/10_安卓客户端取日志脚本/","text":"安卓客户端取日志脚本：8ii8i i 1234567891011121314151617181920212223242526272829303132333435363738394041@echo off::初始化脚本:startclsecho ****************************************echo [请输入：0] 退出echo [请输入：1] 获取applogecho [请输入：2] 清理applogecho [直接输入回车] 执行默认操作echo ****************************************set FOLDER=%~dp0set TIMESTAMP=%date:~0,4%%date:~5,2%%date:~8,2%_%time:~0,2%%time:~3,2%%time:~6,2%set /p opt=请输入:if &quot;%opt%&quot;==&quot;0&quot; goto exitif &quot;%opt%&quot;==&quot;1&quot; goto get_logif &quot;%opt%&quot;==&quot;&quot; goto default:defaultecho 执行默认操作echo 我啥也没干pausegoto start:get_logecho opt=%opt%echo 获取applogecho 目标路径为 %FOLDER%%TIMESTAMP%::adb pull applog路径 目标路径pausegoto start:clean_logecho opt=%opt%echo 清理applogadb remount::adb shell rm -r xxxpausegoto start"},{"title":"ADB常用命令","date":"2018-07-01T12:32:18.000Z","path":"2018/07/01/09_ADB常用命令/","text":"adb 命令 含义 adb shell adb shell “dumpsys window \\ grep mCurrentFocus” 获取应用包名（打开应用） adb shell pm path 包名 获取应用安装路径 adb shell “pm dump 包名 获取应用版本号 adb shell “cat /system/build.prop 获取手机系统信息（ CPU，厂商名称等） adb shell getprop ro.build.version.release 获取手机系统版本 adb shell getprop ro.build.version.sdk 获取手机系统api版本 adb -d shell getprop ro.product.model 获取手机设备型号 adb -d shell getprop ro.product.brand 获取手机厂商名称 adb shell getprop ro.serialno 获取手机的序列号 adb shell dumpsys iphonesubinfo 获取手机的IMEI adb shell cat /sys/class/net/wlan/address 获取手机mac地址 adb shell cat /proc/meminfo 获取手机内存信息 adb shell df 获取手机存储信息 adb shell df /mnt/shell/emulated 获取手机内部存储信息： adb shell df /storage/sdcard 获取sdcard存储信息： adb shell “dumpsys window 获取手机分辨率 adb shell wm density 获取手机物理密度 adb shell “dumpsys window 获取当前界面对应的活动和包名 待刷新"},{"title":"使用selenium+wget实现自动下载图片","date":"2018-03-05T15:04:42.000Z","path":"2018/03/05/08_使用selenium-wget实现自动下载图片/","text":"操作步骤unsplash.com是一个免费下载高清图片的网站，我们可以使用web自动化工具selenium来批量获取该网站主页上提供的海量图片下载链接，并使用强大的多线程下载工具wget下载这些图片。 另外，selenium需要配合chromedriver.exe来操控谷歌浏览器，我们可以通过搜索下载对应浏览器版本的chromedriver.exe 环境安装 selenium wget pip install selenium pip install wget python脚本from selenium import webdriver import wget import os import time import subprocess def mkdir(path): # 去除首位空格 path=path.strip() # 去除尾部 \\ 符号 path=path.rstrip(&quot;\\\\&quot;) # 判断路径是否存在 # 存在 True # 不存在 False isExists=os.path.exists(path) # 判断结果 if not isExists: # 如果不存在则创建目录 print (&apos;%s创建成功&apos;%path) # 创建目录操作函数 os.makedirs(path) return True else: # 如果目录存在则不创建，并提示目录已存在 print (&apos;%s目录已存在&apos;%path) return False def download_pic(folderpath=&apos;&apos;,list=[]): i = 1 for url in list: try: # wget.download(url, out=&apos;%s\\\\%d.jpg&apos; %(folderpath,i)) cmd = &apos;C:\\\\Python36\\\\Scripts\\\\wget -O &quot;%s\\\\%d.jpg&quot; &quot;%s&quot;&apos; %(folderpath,i,url) print(cmd) subprocess.Popen(cmd) i += 1 except: print(&apos;skip&apos;) print(&apos;下载成功...&apos;) def craw_url(scroll=&apos;2&apos;,web_url=&apos;&apos;): driver = webdriver.Chrome(&apos;C:\\\\Python36\\\\Lib\\site-packages\\\\chromedriver_binary\\\\chromedriver.exe&apos;) driver.get(web_url) driver.maximize_window() time.sleep(3) urls = [] try: for i in range(1,scroll): pics = driver.find_elements_by_class_name(name=&apos;_2zEKz&apos;) for pic in pics: src = &apos;%s\\n&apos;%pic.get_attribute(name=&apos;src&apos;) src = src.replace(&apos;1000&apos;,&apos;2592&apos;) # print(src) urls.append(src) js=&quot;window.scrollTo(0,document.body.scrollHeight)&quot; driver.execute_script(js) time.sleep(3) print(&quot;循环次数：%d&quot;%i) driver.close() except: driver.close() urls = list(set(urls)) print(&apos;获取图片链接成功...&apos;) return urls if __name__ == &quot;__main__&quot;: download_path = &apos;G:\\\\02_photo\\\\unsplash&apos; url_list=craw_url(scroll=1000,web_url=&apos;https://unsplash.com/&apos;) mkdir(download_path) download_pic(folderpath=download_path,list=url_list) # for url in url_list: # print(url) # try: # f=open(&apos;%s\\\\0_urls.txt&apos;%download_path,&apos;w&apos;) # f.writelines(url_list) # f.close() # except: pass 下载成功"},{"title":"Markdown的使用","date":"2018-02-21T12:32:18.000Z","path":"2018/02/21/07_Markdown的使用/","text":"Markdown的常用方法如下： 1.标题### 三级标题 三级标题2.无序列表123- 列表1- 列表2- 列表2 列表1 列表2 列表2 3.有序列表1231. 列表12. 列表23. 列表3 列表1 列表2 列表3 4.链接[百度](http://www.baidu.com/) 百度 5.图片![](http://img0.ph.126.net/lsmfEETHdhqyL1Yshsk4Ww==/6631563645446087568.jpg) 1&lt;img src=&quot;http://img0.ph.126.net/lsmfEETHdhqyL1Yshsk4Ww==/6631563645446087568.jpg&quot; height = &quot;110&quot; div align=&quot;right&quot;/&gt; 6.引用&gt; *我挥舞着本子和键盘*，**发誓要把这世界写个明明白白**。 我挥舞着本子和键盘，发誓要把这世界写个明明白白。 7.代码引用1`hello world` hello world 123for() &#123;i++;&#125; 123for() &#123; i++;&#125; 8.表格1234|姓名|学号|成绩||----|:----:|----:||张三|35|60||李四|33|59| 姓名 学号 成绩 张三 35 60 李四 33 59 8. 换行 直接用空行来代表换行 或者在行位连续输入2个空格来代表换行"},{"title":"百日囚徒问题","date":"2017-12-27T15:09:37.000Z","path":"2017/12/27/06_百日囚徒问题/","text":"有100个无期徒刑囚徒，被关在100个独立的小房间，互相无法通信。每天会有一个囚徒被随机地抽出来放风，随机就是说可能被抽到多次。放风的地方有一盏灯，囚徒可以打开或者关上，除囚徒外，没有别人会去动这个灯。每个人除非出来防风，是看不到这个灯的。 一天，全体囚徒大会，国王大赦，给大家一个机会：如果某一天，某个囚徒能够明确表示，所有的囚徒都已经被放过风了，而且的确如此，那么所有囚徒释放；如果仍有囚徒未被放过风，那么所有的囚徒一起处死！ 囚徒大会后给大家20分钟时间讨论，囚徒们能找到方法么？不考虑什么犯人突然死亡的意外因素。是纯粹的理论题。 思路1、前100天利用灯来互相确认自己的身份（灯初始状态为关闭）： 计数人 首次放风的人不进行任何操作，设第一个二次放风的人为计数人，计数人把灯打开（比如第20天该囚犯第二次去放风，且前面没有人去动过灯，则说明连同他共有19个人是首次放风），则此时生成一个该天数的计数(N-1) 已知囚徒 设剩下的99人中，见到过灯灭状态的人为已知囚徒，因为计数人能通过开灯的日期准确推算出之前的人数 未知囚徒 设从未见过灯灭状态的人为未知囚徒，因为灯打开后，计数人无法获取放风的准确人数 这里有可能出现最好情况：第100天，某首次放风囚徒发现灯为关闭状态，说明前100天均无人2次放风，即每人都是首次放风，可以宣布获救。 2、100天过后，未知囚徒和计数人之间通过灯来传递信息（灯初始状态为打开）： 已知囚徒放风 不进行任何操作 未知囚徒放风 若灯为打开状态，说明通信可用，关灯向计数人传递信息，至此该未知囚徒以后都不再对灯进行操作。 若灯为关闭状态，说明此次通信未结束，不进行任何操作 计数人放风 若灯为关闭状态，计数N+1，并将灯打开，以便下一个未知囚徒传递信息 若灯为打开状态，说明暂时没有未知囚徒发起通信，不进行任何操作 当计数人放风时恰好N=100，则他可以宣布确定所有囚徒都放过风了。 代码import random days = 1 # 天数 light = 0 # 灯 times = [0 for i in range(0,100)] # 每个囚徒放风次数的统计数组 counter = -1 # 计数人 remainer = 100 # 剩余未知人 while 1==1: print(&quot;第%d天: &quot;%days) print(&quot; 剩余未知人: %d&quot;%remainer) # 随机抽选一人放风 P = random.randint(0, 99) # 前100天确认身份 if days &lt;= 100: if light == 0: times[P] += 1 # 灯灭放风有效 if times == 1: pass if times[P] == 2: # 灯灭且第二次放风 counter = P print(&quot; 确定计数人: %d&quot; %counter) light = 1 remainer -= (days-1) # 开灯计数 else: pass # 在灯亮放风无效 if days == 100 and light == 0: # 100天灯仍灭，获救 print(&quot;获救&quot;) break else: # 100天后通过灯通信 if light == 1: times[P] += 1 # 灯亮放风有效 if times[P] == 1: #(未知者)关灯发出信息 light = 0 else: if P == counter: # 灯灭计数人开灯计数 light = 1 remainer -= 1 if remainer == 0: print(&quot; 计数人%d宣布获救&quot; %counter) break days += 1 日志第1天: 剩余未知人: 100 第2天: 剩余未知人: 100 第3天: 剩余未知人: 100 第4天: 剩余未知人: 100 第5天: 剩余未知人: 100 第6天: 剩余未知人: 100 第7天: 剩余未知人: 100 确定计数人: 53 第8天: 剩余未知人: 94 第9天: 剩余未知人: 94 ······ 第9538天: 剩余未知人: 1 第9539天: 剩余未知人: 1 第9540天: 剩余未知人: 1 第9541天: 剩余未知人: 1 计数人53宣布获救"},{"title":"基于android实现一个简单的备忘录app","date":"2017-05-20T12:13:59.000Z","path":"2017/05/20/05_基于android实现一个简单的备忘录app/","text":"增删查改的实现创建主活动及布局文件 主活动是整个app的入口，还原一下用户的使用场景： 点击新增按钮：进入AddContent活动 点击备忘录列表上的某个Item：进入对应的备忘录的查看界面 布局文件中应该有一个新建备忘录的Button和一个显示备忘录列表的ListView。 在MainActivity中创建对象根据id获取到上述布局实体并添加逻辑。 对Button设置点击监听事件并重写点击方法（跳转到新增备忘录的活动）: newbtn.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Intent i = new Intent(MainActivity.this, AddContent.class); startActivity(i); &#125; ); 对ListView绑定ListViewAdapter用于绘制ListView的每一个Item中的显示内容；另外为ListView的Item设置点击监听事件并重写点击方法（跳转到查看备忘录的活动）： lv.setOnItemClickListener(this); @Override public void onItemClick(AdapterView&lt;?&gt; parent, View view, int position, long id) &#123; cursor = dbReader.query(NotesDB.TABLE_NAME, null, null, null, null, null, null); cursor.moveToPosition(position); Intent j = new Intent(MainActivity.this,ShowContent.class); j.putExtra(NotesDB.ID, cursor.getInt(cursor.getColumnIndex(NotesDB.ID))); j.putExtra(NotesDB.CONTENT, cursor.getString(cursor.getColumnIndex(NotesDB.CONTENT))); j.putExtra(NotesDB.TIME, cursor.getString(cursor.getColumnIndex(NotesDB.TIME))); startActivity(j); &#125; 创建数据库 重写了两个方法，分别是创建数据库和更新数据库。 其中onUpgrade()方法确保app在覆盖安装时不会覆盖原有的数据库。 @Override public void onCreate(SQLiteDatabase db) &#123; db.execSQL(&quot;CREATE TABLE &quot; + TABLE_NAME + &quot;(&quot; + ID +&quot; INTEGER PRIMARY KEY AUTOINCREMENT,&quot; + CONTENT + &quot; TEXT NOT NULL,&quot; + TIME + &quot; TEXT NOT NULL)&quot;);//最后的括号不能忘 &#125; @Override public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) &#123; &#125; 创建添加备忘的活动及布局文件 用户的使用场景： 进入AddContent活动输入文字 点击取消按钮：返回MainActivity界面 点击保存按钮：输入的文字和当前日期时间被存入数据库 布局包括一个输入文字的EditText和两个Button分别用于保存和取消。 在活动中为两个按钮设置点击监听事件重写点击方法： 取消按钮：finish()当前活动；需要注意的是，要想返回的活动是主界面必须在Manifest文件中为主活动添加android:launchMode=&quot;singleTask&quot;的声明。 保存按钮：将EditText中的文字和当前时间用ContentValue对象存入数据库；注意获取当前时间用SimpleDateFormat的format方法来得到Date对象的合适的格式，返回值类型为String。 ContentValue和数据库的写入方法如下： public void addDB() &#123; ContentValues cv = new ContentValues(); cv.put(NotesDB.CONTENT,edtext.getText().toString()); cv.put(NotesDB.TIME, getTime()); dbWriter.insert(NotesDB.TABLE_NAME, null, cv); &#125; private String getTime() &#123; SimpleDateFormat format = new SimpleDateFormat(&quot;yyyy年MM月dd日 HH:mm:ss&quot;); Date date = new Date(); String str = format.format(date); return str; &#125; 创建查看备忘的活动及布局文件 用户的使用场景： 123进入ShowContent活动查看备忘录详细内容（包括存在数据库中的时间）点击返回按钮：返回MainActivity界面；点击删除按钮：删除数据库中的对应记录，并保证主活动中的列表也同步 布局包括一个用来显示文字的EditText和两个Button分别用于返回和删除。 活动中两个按钮的点击监听事件： 返回按钮同新增活动中的取消按钮 删除按钮的onClick方法中的删除数据库记录的代码如下： 1234public void deleteData() &#123; dbWriter.delete(NotesDB.TABLE_NAME, &quot;_id=&quot;+getIntent().getIntExtra(NotesDB.ID, 0), null);&#125; 活动中的EditText是用来显示备忘内容的因此将编辑属性关闭，备忘内容从启动该活动的Intent中获取。 1234s_edtxt.setText(this.getIntent().getStringExtra(NotesDB.CONTENT));s_edtxt. setCursorVisible ( false ) ; s_edtxt.setFocusable(false); s_edtxt.clearFocus(); 创建修改备忘的活动及布局文件 用户的使用场景： 123进入UpdateContent活动修改备忘录详细内容（同时更新存在数据库中的时间）点击返回按钮：返回MainActivity界面；点击保存按钮：输入的文字和当前日期时间覆盖数据库中对应的记录 布局包括EditText和两个Button+活动中为两个按钮设置点击监听事件： 返回按钮同新增活动中的取消按钮 保存按钮同新增按钮中的保存按钮 活动中的EditText除了要显示原有的备忘内容外，还要有可以编辑的属性： 1234u_edtxt.setText(this.getIntent().getStringExtra(NotesDB.CONTENT));u_edtxt. setCursorVisible (true) ;u_edtxt.setFocusable(true);u_edtxt.setSelection(u_edtxt.getText().toString().length()); 在Manifest文件中注册活动：12345678910111213141516171819202122232425262728293031323334353637&lt;application android:allowBackup=&quot;true&quot; android:icon=&quot;@mipmap/ic_note_white&quot; android:label=&quot;@string/app_name&quot; android:supportsRtl=&quot;true&quot; android:theme=&quot;@style/AppTheme.NoActionBar&quot;&gt; &lt;activity android:name=&quot;.activity.MainActivity&quot; android:label=&quot;@string/app_name&quot; android:launchMode=&quot;singleTask&quot; android:screenOrientation=&quot;portrait&quot; android:theme=&quot;@style/AppTheme.NoActionBar&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt; &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;activity android:name=&quot;.activity.AddContent&quot; android:label=&quot;新增日程&quot; android:screenOrientation=&quot;portrait&quot; android:theme=&quot;@style/AppTheme.NoActionBar&quot; android:windowSoftInputMode=&quot;adjustResize&quot;&gt;&lt;/activity&gt; &lt;activity android:name=&quot;.activity.ShowContent&quot; android:label=&quot;查看日程&quot; android:screenOrientation=&quot;portrait&quot; android:theme=&quot;@style/AppTheme.NoActionBar&quot;&gt;&lt;/activity&gt; &lt;activity android:name=&quot;.activity.UpdateContent&quot; android:label=&quot;修改日程&quot; android:screenOrientation=&quot;portrait&quot; android:theme=&quot;@style/AppTheme.NoActionBar&quot; android:windowSoftInputMode=&quot;adjustResize&quot;&gt;&lt;/activity&gt; &lt;/application&gt; 至此，备忘录的增删改查功能已经添加完毕。 云端同步功能实现同步功能概述备忘录的云端同步可以让用户在多个设备间同步数据，并提供数据备份功能。实现云同步需要考虑以下几个方面： 数据存储方案 用户认证 同步策略 冲突处理 推荐的技术方案1. 后端存储选择 LeanCloud (推荐) 提供开箱即用的数据存储 内置用户系统 有完整的Android SDK 免费额度足够个人开发者使用 Firebase (替代方案) Google官方支持 实时数据同步 较完善的离线支持 2. 数据表设计123456789Note &#123; objectId: String // 唯一标识 content: String // 备忘内容 createTime: Date // 创建时间 updateTime: Date // 更新时间 userId: String // 用户ID isDeleted: Boolean // 软删除标记 version: Number // 版本号(用于冲突处理)&#125; 实现步骤 (TodoList)1. 基础配置 [ ] 注册LeanCloud账号并创建应用 [ ] 添加LeanCloud SDK依赖 [ ] 在Application中初始化SDK [ ] 配置AndroidManifest添加所需权限 2. 用户系统 [ ] 实现注册界面 [ ] 实现登录界面 [ ] 实现用户信息存储 [ ] 添加登出功能 3. 数据同步 [ ] 修改本地数据库结构，增加同步相关字段 [ ] 实现数据上传功能 [ ] 实现数据下载功能 [ ] 添加定时同步服务 4. 冲突处理 [ ] 实现版本控制 [ ] 添加冲突检测逻辑 [ ] 实现冲突解决策略 5. 离线支持 [ ] 实现本地缓存 [ ] 添加离线操作队列 [ ] 网络恢复后自动同步 代码示例LeanCloud初始化12345678public class MyApplication extends Application &#123; @Override public void onCreate() &#123; super.onCreate(); // 初始化参数依次为 this, AppId, AppKey AVOSCloud.initialize(this,&quot;your_app_id&quot;,&quot;your_app_key&quot;); &#125;&#125; 数据同步示例12345678910111213141516171819202122public class SyncService &#123; public void syncNote(Note note) &#123; AVObject avNote = new AVObject(&quot;Note&quot;); avNote.put(&quot;content&quot;, note.getContent()); avNote.put(&quot;createTime&quot;, note.getCreateTime()); avNote.put(&quot;updateTime&quot;, new Date()); avNote.put(&quot;userId&quot;, AVUser.getCurrentUser().getObjectId()); avNote.put(&quot;version&quot;, note.getVersion()); avNote.saveInBackground().subscribe(new Observer&lt;AVObject&gt;() &#123; @Override public void onSuccess(AVObject avObject) &#123; // 同步成功处理 &#125; @Override public void onError(Throwable throwable) &#123; // 错误处理 &#125; &#125;); &#125;&#125; 注意事项 数据安全 设置适当的ACL权限 敏感数据加密存储 使用HTTPS传输 性能优化 批量同步而不是单条同步 合理设置同步频率 压缩数据包大小 用户体验 同步状态提示 网络异常处理 后台静默同步 耗电优化 使用WorkManager调度同步任务 根据网络状态调整同步策略 避免频繁同步 后续优化方向 支持多设备同步 添加同步历史记录 实现数据版本回滚 添加同步设置选项 支持选择性同步 参考文档： LeanCloud 文档中心 Android WorkManager Android 数据同步最佳实践"},{"title":"遇到乱码问题的解决方案","date":"2017-03-29T14:25:23.000Z","path":"2017/03/29/04_GBK和UTF-8的区别/","text":"编码的概念 GBK编码：是指中国的中文字符，其它它包含了简体中文与繁体中文字符，另外还有一种字符“gb2312”，这种字符仅能存储简体中文字符。 UTF-8编码：它是一种全国家通过的一种编码，如果你的网站涉及到多个国家的语言，那么建议你选择UTF-8编码。 GBK和UTF8有什么区别？ UTF8编码格式很强大，支持所有国家的语言，正是因为它的强大，才会导致它占用的空间大小要比GBK大，对于网站打开速度而言，也是有一定影响的。 GBK编码格式，它的功能少，仅限于中文字符，当然它所占用的空间大小会随着它的功能而减少，打开网页的速度比较快。 如何在sublime中添加对中文的支持 首先安装Package control工具：在Sublime Text里，按ctrl+`，打开Console，一次性输入如下代码： 1import urllib.request,os; pf = &#x27;Package Control.sublime-package&#x27;; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); open(os.path.join(ipp, pf), &#x27;wb&#x27;).write(urllib.request.urlopen( &#x27;http://sublime.wbond.net/&#x27; + pf.replace(&#x27; &#x27;,&#x27;%20&#x27;)).read()) 然后按ctrl shift p 打开命令行模式：输入Install Package关键字，然后点击自动出现的下拉菜单里的第一项：Package Control: Install Package(回车无效) PS：执行上述步骤不要急，左下角会有一个等于号来回动，看着它也许你会安静点。。 稍等一会，会再次在命令行下弹出一个下拉菜单。输入“ConvertToUTF8”或者“GBK Encoding Support”，选择匹配项。中文字符就可以正常显示了。 Tips： 养成将手敲的代码存为 UTF-8 编码格式的习惯 遇到乱码首先尝试转 UTF-8 切忌一看到乱码先乱删一通，然后气急败坏地把代码文件全删了"},{"title":"冒泡排序算法","date":"2017-03-26T15:56:26.000Z","path":"2017/03/26/03_冒泡排序算法/","text":"(对 n 个数降序)冒泡排序的思路是： 1、最多进行 (n-1) 次排序 2、每次排序将从第一个开始遍历和后一个数比较（确定是否执行交换位置） 值得注意的是本次排序后会产生一个最小数，下次排序可以不用和该数进行比较的判断 关于复杂度的概念还未与其他排序算法比较 代码如下：1234567891011121314151617181920212223242526272829303132public class MyBubbleSort &#123; public static void main(String[] args) &#123; int[] arr = &#123;2,6,3,9,4,5,1,2,5,8&#125;; int len = arr.length; for (int i=0;i&lt;len-1;i++) &#123; for (int j=0;j&lt;len-1-i;j++)//减i的原因是经过i+1次排序后倒数第i+1个数都是确认最小的 &#123; if(arr[j]&lt;arr[j+1]) &#123; int temp = 0; temp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = temp; &#125; &#125; System.out.print(&quot;第&quot;+(i+1)+&quot;次排序结果:&quot;); for(int a = 0; a &lt;len;a++) &#123; System.out.print(arr[a] + &quot;\\t&quot;); &#125; System.out.println(&quot;&quot;); &#125; System.out.print(&quot;最终排序结果为：&quot;); for(int a = 0; a &lt;len;a++) &#123; System.out.print(arr[a] + &quot;\\t&quot;); &#125; System.out.println(&quot;&quot;); &#125;&#125;"},{"title":"git常用命令","date":"2017-01-13T17:21:22.000Z","path":"2017/01/14/02_git常用命令/","text":"创建本地仓库git init.git所在文件夹便是git对应的一个本地仓库 创建本地分支git branch master 查看本地分支git branch 设置远程仓库地址git remote add github git@github.com:regeorge/blog.git 查看已配置的远程仓库git remote 从远程仓库更新到本地分支git pull github master 在未加入缓存区时回滚git checkout -- . 将本文件夹内所有改动加入缓存区git add . 在加入缓存区时回滚git reset HEAD 将暂存区的改动提交到本地仓库git commit -m &quot;add all files&quot; 在提交仓库后回滚git log #查看提交记录（带有唯一标识commitid） git revert %commitid% 将本地分支推送到远程仓库git push github master .gitignore文件中写入不需要同步的文件夹路径hexo deploy 命令在使用hexo搭建博客时，blog目录下有一个.git文件夹，而.deploy_git文件夹内的.git文件夹又对应了另一个仓库,hexo d命令正是将此目录下的仓库推送到远程仓库从而实现更新博客的 FAQ Q1：在github上创建仓库，在本地新建仓库并push产生冲突 A1：先pull后pushgit push -u origin master -f 参考：http://wuchong.me/blog/2014/01/17/use-github-to-manage-hexo-source/ http://blog.csdn.net/shiren1118/article/details/7761203 查看提交历史git log 查看简洁的提交历史git log --oneline 查看文件的修改历史git blame &lt;file&gt; 查看工作目录状态git status 比较工作目录和暂存区的差异git diff 比较暂存区和最后一次提交的差异git diff --cached 创建并切换到新分支git checkout -b &lt;branch_name&gt; 合并分支git merge &lt;branch_name&gt; 删除本地分支git branch -d &lt;branch_name&gt; 删除远程分支git push origin --delete &lt;branch_name&gt; 暂存当前更改以便切换分支git stash 恢复暂存的更改git stash pop 查看所有暂存的更改git stash list 清除所有暂存的更改git stash clear"},{"title":"如何搭建个人博客","date":"2017-01-09T14:27:45.000Z","path":"2017/01/09/01_如何搭建个人博客/","text":"搭建个人主页的步骤如下： 先将我们写的文章或者照片生成静态页面(hexo) 并将这些静态页面部署到支持静态页面的服务器(github或coding) 这样我们就可以通过服务器的域名地址访问到自己的博客了(regeorge.github.io) 下面是操作步骤： 准备环境： node.js（npm）的安装 1、hexo 是基于 node.js 来生成页面的 2、node.js 提供了 npm 包管理工具，后面安装 hexo 只需要几行命令 hexo 的安装和初始化 1、完成后可以在本地生成默认的博客页面，并通过浏览器预览效果 2、常用的几条命令如下： hexo n p &apos;文章标题&apos; //新建文章 hexo g //生成页面 hexo s //本地预览 hexo d //提交页面 Hexo 常用部署命令详解 hexo g (hexo generate) 作用：生成静态文件 原理： 读取 source 目录下的文件（主要是 markdown） 根据主题模板将内容渲染成 HTML 生成的静态文件存放在 public 目录 包含 HTML、CSS、JavaScript 等资源文件 hexo s (hexo server) 作用：启动本地预览服务器 原理： 启动一个 Node.js 服务器 默认监听 4000 端口 将 public 目录作为网站根目录 支持实时预览（修改文件后自动更新） hexo d (hexo deploy) 作用：部署网站到远程服务器 原理： 首先将 public 目录下的文件复制到 .deploy_git 目录 在 .deploy_git 目录初始化 Git 仓库（如果不存在） 添加远程仓库（通常是 GitHub Pages） 提交所有文件并推送到远程仓库 hexo s -g 作用：生成静态文件并启动预览服务器 原理： 相当于顺序执行 hexo g 和 hexo s 生成的文件存在内存中，服务器关闭后不保存 用于本地快速预览效果 hexo g -d 作用：生成静态文件并立即部署 原理： 相当于顺序执行 hexo g 和 hexo d 先生成静态文件到 public 目录 然后立即部署到远程服务器 常用于确认内容无误后的发布 git 的安装和配置 1、git是用作版本控制的，也就是在本地生成的博客都是通过git来同步到云端服务器 2、上一条的提交页面命令hexo d其实就是通过git将页面提交到配置文件中填写的github仓库的 github 的注册和配置 1、github 提供了一个静态页面服务功能，这里要做的是在github上创建一个指定名称的仓库来放置本地生成好的博客页面文件 2、同时还需要把这个创建好的仓库地址填写到本地的配置信息中 具体的安装步骤请参考gdutxiaoxu的文章，每一步都非常详细：手把手教你用Hexo+Github 搭建属于自己的博客 配置主题跟着上述参考文章的操作步骤配置好环境后，已经可以在本地预览到生成的博客界面了，按照这种方法生成的页面其实都是一样的，要让自己的博客不一样，一是要时常更新自己的文章，二是自定义页面的样式，网上也提供了很多开源的主题可以配置，非常方便，我推荐的主题有Next，Yilia，Yelee，更多的主题可以百度hexo theme 配置的方法就是将主题通过git pull到博客的theme目录下，然后按照该主题的说明文档（github上的readme.md）进行修改自定义的配置 提交页面假设我们已经上面的参考文章配置好了提交的地址：在博客的根目录的配置文件_config.yml中 # Deployment deploy: type: git repo: github: git@github.com:reGeorge/regeorge.github.io.git,master //github仓库 coding: git@git.coding.net:reGeorge/reGeorge.git,master //coding仓库 branch: master 这里我配置了两个地址，执行hexo d命令时会分别向两个仓库推送本地生成的页面，这样我通过两个域名都可以访问到我的博客（coding国内访问的速度更快） https://regeorge.github.io/ http://regeorge.coding.me/ 踩坑记录 hexo d 命令不生效 原因是 GitHub 的 workflows 配置不正确 解决方法: 在项目中创建 deploy.yml 文件 配置从 master 分支拉取静态网页文件的目录 发布到 gh-pages 分支以触发 GitHub Pages 的发布 themes 目录中自定义 js 方法报错 问题:传入 tags.toArrays() 方法时报错 解决方法: 只需要在调用前判空处理 无需使用 toArrays() 方法"}]
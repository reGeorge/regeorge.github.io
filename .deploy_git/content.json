[{"title":"测试工作的一些总结","date":"2019-07-07T12:32:18.000Z","path":"2019/07/07/15_测试工作的一些总结/","text":"手工测试测试流程规范 产品从立项到发布要经历的流程 立项流程：收集需求（用户、销售、领导等）-&gt;立项（产品经理）-&gt;决策（领导） 设计阶段：需求澄清（产品经理）-&gt;产品设计（UI、架构）-&gt;开发story-&gt;测试方案 开发&amp;转测：进度把控-风险评估 客户验收：结项 测试的职责 输出测试设计和测试用例并由相关人员一起评审（BA，开发，项目经理，测试） 执行测试用例 缺陷跟踪 输出测试报告、测试总结等 测试人员需要掌握的技能 产品从立项到发布的各个流程中，测试需要关注的地方 立项流程中，收集需求这个环节，测试在执行用例期间遇到非bug类的体验问题要本地记录，并汇总反馈给产品经理 设计阶段的评审环节，测试要多从用户体验的角度提出自己的观点和疑问（测试比开发更接近用户，比销售更熟悉产品的实现） 测试方案、测试用例、测试执行、缺陷跟踪是测试的核心职责 测试方案要覆盖全面（测试目的、测试准备、测试分工、测试范围、测试风险） 测试用例要按照功能测试设计将操作步骤、检查点逐一细化 测试执行要覆盖到测试用例的每一个测试步骤和检查点 缺陷跟踪要在回归问题场景的基础上，弄清bug的根因和修改方案，回归测试要考虑到是否需要补充测试方案和测试用例 参考：怎样制定一个合格的测试方案 常见客户端测试工具的使用 ADB参考： SqliteStudio参考： tcpdump参考:tcpdump的使用 wireshark参考:wireshark的使用 自动化测试 常见的自动化测试框架 Appium和Selenium了解 开源的自动化框架上手 自动化脚本编写语言 java和python 自动化构建的思路 从脚本到aw，再到框架 自动构建任务，远程执行 测试报告的生成 从手工用例到自动化用例转化的注意点 自动化用例覆盖范围的评审 自动化用例执行失败用例的定位"},{"title":"让你的hexo支持mermaid","date":"2019-05-26T08:56:24.000Z","path":"2019/05/26/11_让你的Hexo支持mermaid/","text":"mermaid配置方法 npm安装插件 blog根目录config文件中添加配置 主题文件中添加过滤标签 补充：blog根目录中package.json文件中添加依赖（参考文章中没有提到） 参考文章： https://www.liuyude.com/How_to_make_your_HEXO_blog_support_handwriting_flowchart.html https://github.com/webappdevelp/hexo-filter-mermaid-diagrams hexo绘制脑图参考文章： https://qsli.github.io/2017/01/01/markdown-mindmap/ https://github.com/HunterXuan/hexo-simple-mindmap 配置完成后，使用mermaid语法流程图graph TD; A-->B; A-->C; B-->D; C-->D; 时序图sequenceDiagram participant Alice participant Bob Alice->John: Hello John, how are you? loop Healthcheck John->John: Fight against hypochondria end Note right of John: Rational thoughts prevail... John-->Alice: Great! John->Bob: How about you? Bob-->John: Jolly good! 甘特图gantt dateFormat YYYY-MM-DD title Adding GANTT diagram functionality to mermaid section A section Completed task :done, des1, 2014-01-06,2014-01-08 Active task :active, des2, 2014-01-09, 3d Future task : des3, after des2, 5d Future task2 : des4, after des3, 5d section Critical tasks Completed task in the critical line :crit, done, 2014-01-06,24h Implement parser and jison :crit, done, after des1, 2d Create tests for parser :crit, active, 3d Future task in critical line :crit, 5d Create tests for renderer :2d Add to mermaid :1d 脑图 在 Hexo 中使用思维导图 前言 操作指南 准备需要的文件 为主题添加 CSS/JS 文件 使用方法"},{"title":"安卓客户端取日志脚本","date":"2019-04-01T12:32:18.000Z","path":"2019/04/01/10_安卓客户端取日志脚本/","text":"安卓客户端取日志脚本： 1234567891011121314151617181920212223242526272829303132333435363738394041@echo off::初始化脚本:startclsecho ****************************************echo [请输入：0] 退出echo [请输入：1] 获取applogecho [请输入：2] 清理applogecho [直接输入回车] 执行默认操作echo ****************************************set FOLDER=%~dp0set TIMESTAMP=%date:~0,4%%date:~5,2%%date:~8,2%_%time:~0,2%%time:~3,2%%time:~6,2%set /p opt=请输入:if &quot;%opt%&quot;==&quot;0&quot; goto exitif &quot;%opt%&quot;==&quot;1&quot; goto get_logif &quot;%opt%&quot;==&quot;&quot; goto default:defaultecho 执行默认操作echo 我啥也没干pausegoto start:get_logecho opt=%opt%echo 获取applogecho 目标路径为 %FOLDER%%TIMESTAMP%::adb pull applog路径 目标路径pausegoto start:clean_logecho opt=%opt%echo 清理applogadb remount::adb shell rm -r xxxpausegoto start"},{"title":"ADB常用命令","date":"2018-07-01T12:32:18.000Z","path":"2018/07/01/09_ADB常用命令/","text":"adb 命令 含义 adb shell adb shell “dumpsys window \\ grep mCurrentFocus” 获取应用包名（打开应用） adb shell pm path 包名 获取应用安装路径 adb shell “pm dump 包名 获取应用版本号 adb shell “cat /system/build.prop 获取手机系统信息（ CPU，厂商名称等） adb shell getprop ro.build.version.release 获取手机系统版本 adb shell getprop ro.build.version.sdk 获取手机系统api版本 adb -d shell getprop ro.product.model 获取手机设备型号 adb -d shell getprop ro.product.brand 获取手机厂商名称 adb shell getprop ro.serialno 获取手机的序列号 adb shell dumpsys iphonesubinfo 获取手机的IMEI adb shell cat /sys/class/net/wlan/address 获取手机mac地址 adb shell cat /proc/meminfo 获取手机内存信息 adb shell df 获取手机存储信息 adb shell df /mnt/shell/emulated 获取手机内部存储信息： adb shell df /storage/sdcard 获取sdcard存储信息： adb shell “dumpsys window 获取手机分辨率 adb shell wm density 获取手机物理密度 adb shell “dumpsys window 获取当前界面对应的活动和包名 待刷新"},{"title":"使用selenium+wget实现自动下载图片","date":"2018-03-05T15:04:42.000Z","path":"2018/03/05/08_使用selenium-wget实现自动下载图片/","text":"操作步骤unsplash.com是一个免费下载高清图片的网站，我们可以使用web自动化工具selenium来批量获取该网站主页上提供的海量图片下载链接，并使用强大的多线程下载工具wget下载这些图片。 另外，selenium需要配合chromedriver.exe来操控谷歌浏览器，我们可以通过搜索下载对应浏览器版本的chromedriver.exe 环境安装 selenium wget pip install selenium pip install wget python脚本from selenium import webdriver import wget import os import time import subprocess def mkdir(path): # 去除首位空格 path=path.strip() # 去除尾部 \\ 符号 path=path.rstrip(&quot;\\\\&quot;) # 判断路径是否存在 # 存在 True # 不存在 False isExists=os.path.exists(path) # 判断结果 if not isExists: # 如果不存在则创建目录 print (&apos;%s创建成功&apos;%path) # 创建目录操作函数 os.makedirs(path) return True else: # 如果目录存在则不创建，并提示目录已存在 print (&apos;%s目录已存在&apos;%path) return False def download_pic(folderpath=&apos;&apos;,list=[]): i = 1 for url in list: try: # wget.download(url, out=&apos;%s\\\\%d.jpg&apos; %(folderpath,i)) cmd = &apos;C:\\\\Python36\\\\Scripts\\\\wget -O &quot;%s\\\\%d.jpg&quot; &quot;%s&quot;&apos; %(folderpath,i,url) print(cmd) subprocess.Popen(cmd) i += 1 except: print(&apos;skip&apos;) print(&apos;下载成功...&apos;) def craw_url(scroll=&apos;2&apos;,web_url=&apos;&apos;): driver = webdriver.Chrome(&apos;C:\\\\Python36\\\\Lib\\site-packages\\\\chromedriver_binary\\\\chromedriver.exe&apos;) driver.get(web_url) driver.maximize_window() time.sleep(3) urls = [] try: for i in range(1,scroll): pics = driver.find_elements_by_class_name(name=&apos;_2zEKz&apos;) for pic in pics: src = &apos;%s\\n&apos;%pic.get_attribute(name=&apos;src&apos;) src = src.replace(&apos;1000&apos;,&apos;2592&apos;) # print(src) urls.append(src) js=&quot;window.scrollTo(0,document.body.scrollHeight)&quot; driver.execute_script(js) time.sleep(3) print(&quot;循环次数：%d&quot;%i) driver.close() except: driver.close() urls = list(set(urls)) print(&apos;获取图片链接成功...&apos;) return urls if __name__ == &quot;__main__&quot;: download_path = &apos;G:\\\\02_photo\\\\unsplash&apos; url_list=craw_url(scroll=1000,web_url=&apos;https://unsplash.com/&apos;) mkdir(download_path) download_pic(folderpath=download_path,list=url_list) # for url in url_list: # print(url) # try: # f=open(&apos;%s\\\\0_urls.txt&apos;%download_path,&apos;w&apos;) # f.writelines(url_list) # f.close() # except: pass 下载成功"},{"title":"Markdown的使用","date":"2018-02-21T12:32:18.000Z","path":"2018/02/21/07_Markdown的使用/","text":"Markdown的常用方法如下： 1.标题### 三级标题 三级标题2.无序列表123- 列表1- 列表2- 列表2 列表1 列表2 列表2 3.有序列表1231. 列表12. 列表23. 列表3 列表1 列表2 列表3 4.链接[百度](http://www.baidu.com/) 百度 5.图片![](http://img0.ph.126.net/lsmfEETHdhqyL1Yshsk4Ww==/6631563645446087568.jpg) 1&lt;img src=&quot;http://img0.ph.126.net/lsmfEETHdhqyL1Yshsk4Ww==/6631563645446087568.jpg&quot; height = &quot;110&quot; div align=&quot;right&quot;/&gt; 6.引用&gt; *我挥舞着本子和键盘*，**发誓要把这世界写个明明白白**。 我挥舞着本子和键盘，发誓要把这世界写个明明白白。 7.代码引用1`hello world` hello world 123for() &#123;i++;&#125; 123for() &#123; i++;&#125; 8.表格1234|姓名|学号|成绩||----|:----:|----:||张三|35|60||李四|33|59| 姓名 学号 成绩 张三 35 60 李四 33 59 8. 换行 直接用空行来代表换行 或者在行位连续输入2个空格来代表换行"},{"title":"百日囚徒问题","date":"2017-12-27T15:09:37.000Z","path":"2017/12/27/06_百日囚徒问题/","text":"有100个无期徒刑囚徒，被关在100个独立的小房间，互相无法通信。每天会有一个囚徒被随机地抽出来放风，随机就是说可能被抽到多次。放风的地方有一盏灯，囚徒可以打开或者关上，除囚徒外，没有别人会去动这个灯。每个人除非出来防风，是看不到这个灯的。 一天，全体囚徒大会，国王大赦，给大家一个机会：如果某一天，某个囚徒能够明确表示，所有的囚徒都已经被放过风了，而且的确如此，那么所有囚徒释放；如果仍有囚徒未被放过风，那么所有的囚徒一起处死！ 囚徒大会后给大家20分钟时间讨论，囚徒们能找到方法么？不考虑什么犯人突然死亡的意外因素。是纯粹的理论题。 思路1、前100天利用灯来互相确认自己的身份（灯初始状态为关闭）： 计数人 首次放风的人不进行任何操作，设第一个二次放风的人为计数人，计数人把灯打开（比如第20天该囚犯第二次去放风，且前面没有人去动过灯，则说明连同他共有19个人是首次放风），则此时生成一个该天数的计数(N-1) 已知囚徒 设剩下的99人中，见到过灯灭状态的人为已知囚徒，因为计数人能通过开灯的日期准确推算出之前的人数 未知囚徒 设从未见过灯灭状态的人为未知囚徒，因为灯打开后，计数人无法获取放风的准确人数 这里有可能出现最好情况：第100天，某首次放风囚徒发现灯为关闭状态，说明前100天均无人2次放风，即每人都是首次放风，可以宣布获救。 2、100天过后，未知囚徒和计数人之间通过灯来传递信息（灯初始状态为打开）： 已知囚徒放风 不进行任何操作 未知囚徒放风 若灯为打开状态，说明通信可用，关灯向计数人传递信息，至此该未知囚徒以后都不再对灯进行操作。 若灯为关闭状态，说明此次通信未结束，不进行任何操作 计数人放风 若灯为关闭状态，计数N+1，并将灯打开，以便下一个未知囚徒传递信息 若灯为打开状态，说明暂时没有未知囚徒发起通信，不进行任何操作 当计数人放风时恰好N=100，则他可以宣布确定所有囚徒都放过风了。 代码import random days = 1 # 天数 light = 0 # 灯 times = [0 for i in range(0,100)] # 每个囚徒放风次数的统计数组 counter = -1 # 计数人 remainer = 100 # 剩余未知人 while 1==1: print(&quot;第%d天: &quot;%days) print(&quot; 剩余未知人: %d&quot;%remainer) # 随机抽选一人放风 P = random.randint(0, 99) # 前100天确认身份 if days &lt;= 100: if light == 0: times[P] += 1 # 灯灭放风有效 if times == 1: pass if times[P] == 2: # 灯灭且第二次放风 counter = P print(&quot; 确定计数人: %d&quot; %counter) light = 1 remainer -= (days-1) # 开灯计数 else: pass # 在灯亮放风无效 if days == 100 and light == 0: # 100天灯仍灭，获救 print(&quot;获救&quot;) break else: # 100天后通过灯通信 if light == 1: times[P] += 1 # 灯亮放风有效 if times[P] == 1: #(未知者)关灯发出信息 light = 0 else: if P == counter: # 灯灭计数人开灯计数 light = 1 remainer -= 1 if remainer == 0: print(&quot; 计数人%d宣布获救&quot; %counter) break days += 1 日志第1天: 剩余未知人: 100 第2天: 剩余未知人: 100 第3天: 剩余未知人: 100 第4天: 剩余未知人: 100 第5天: 剩余未知人: 100 第6天: 剩余未知人: 100 第7天: 剩余未知人: 100 确定计数人: 53 第8天: 剩余未知人: 94 第9天: 剩余未知人: 94 ······ 第9538天: 剩余未知人: 1 第9539天: 剩余未知人: 1 第9540天: 剩余未知人: 1 第9541天: 剩余未知人: 1 计数人53宣布获救"},{"title":"基于android实现一个简单的备忘录app","date":"2017-05-20T12:13:59.000Z","path":"2017/05/20/05_基于android实现一个简单的备忘录app/","text":"增删查改的实现创建主活动及布局文件 主活动是整个app的入口，还原一下用户的使用场景： 点击新增按钮：进入AddContent活动 点击备忘录列表上的某个Item：进入对应的备忘录的查看界面 布局文件中应该有一个新建备忘录的Button和一个显示备忘录列表的ListView。 在MainActivity中创建对象根据id获取到上述布局实体并添加逻辑。 对Button设置点击监听事件并重写点击方法（跳转到新增备忘录的活动）: newbtn.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { Intent i = new Intent(MainActivity.this, AddContent.class); startActivity(i); } ); 对ListView绑定ListViewAdapter用于绘制ListView的每一个Item中的显示内容；另外为ListView的Item设置点击监听事件并重写点击方法（跳转到查看备忘录的活动）： lv.setOnItemClickListener(this); @Override public void onItemClick(AdapterView&lt;?&gt; parent, View view, int position, long id) { cursor = dbReader.query(NotesDB.TABLE_NAME, null, null, null, null, null, null); cursor.moveToPosition(position); Intent j = new Intent(MainActivity.this,ShowContent.class); j.putExtra(NotesDB.ID, cursor.getInt(cursor.getColumnIndex(NotesDB.ID))); j.putExtra(NotesDB.CONTENT, cursor.getString(cursor.getColumnIndex(NotesDB.CONTENT))); j.putExtra(NotesDB.TIME, cursor.getString(cursor.getColumnIndex(NotesDB.TIME))); startActivity(j); } 创建数据库 重写了两个方法，分别是创建数据库和更新数据库。 其中onUpgrade()方法确保app在覆盖安装时不会覆盖原有的数据库。 @Override public void onCreate(SQLiteDatabase db) { db.execSQL(&quot;CREATE TABLE &quot; + TABLE_NAME + &quot;(&quot; + ID +&quot; INTEGER PRIMARY KEY AUTOINCREMENT,&quot; + CONTENT + &quot; TEXT NOT NULL,&quot; + TIME + &quot; TEXT NOT NULL)&quot;);//最后的括号不能忘 } @Override public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) { } 创建添加备忘的活动及布局文件 用户的使用场景： 进入AddContent活动输入文字 点击取消按钮：返回MainActivity界面 点击保存按钮：输入的文字和当前日期时间被存入数据库 布局包括一个输入文字的EditText和两个Button分别用于保存和取消。 在活动中为两个按钮设置点击监听事件重写点击方法： 取消按钮：finish()当前活动；需要注意的是，要想返回的活动是主界面必须在Manifest文件中为主活动添加android:launchMode=&quot;singleTask&quot;的声明。 保存按钮：将EditText中的文字和当前时间用ContentValue对象存入数据库；注意获取当前时间用SimpleDateFormat的format方法来得到Date对象的合适的格式，返回值类型为String。 ContentValue和数据库的写入方法如下： public void addDB() { ContentValues cv = new ContentValues(); cv.put(NotesDB.CONTENT,edtext.getText().toString()); cv.put(NotesDB.TIME, getTime()); dbWriter.insert(NotesDB.TABLE_NAME, null, cv); } private String getTime() { SimpleDateFormat format = new SimpleDateFormat(&quot;yyyy年MM月dd日 HH:mm:ss&quot;); Date date = new Date(); String str = format.format(date); return str; } 创建查看备忘的活动及布局文件 用户的使用场景： 123进入ShowContent活动查看备忘录详细内容（包括存在数据库中的时间）点击返回按钮：返回MainActivity界面；点击删除按钮：删除数据库中的对应记录，并保证主活动中的列表也同步 布局包括一个用来显示文字的EditText和两个Button分别用于返回和删除。 活动中两个按钮的点击监听事件： 返回按钮同新增活动中的取消按钮 删除按钮的onClick方法中的删除数据库记录的代码如下： 1234public void deleteData() &#123; dbWriter.delete(NotesDB.TABLE_NAME, &quot;_id=&quot;+getIntent().getIntExtra(NotesDB.ID, 0), null);&#125; 活动中的EditText是用来显示备忘内容的因此将编辑属性关闭，备忘内容从启动该活动的Intent中获取。 1234s_edtxt.setText(this.getIntent().getStringExtra(NotesDB.CONTENT));s_edtxt. setCursorVisible ( false ) ; s_edtxt.setFocusable(false); s_edtxt.clearFocus(); 创建修改备忘的活动及布局文件 用户的使用场景： 123进入UpdateContent活动修改备忘录详细内容（同时更新存在数据库中的时间）点击返回按钮：返回MainActivity界面；点击保存按钮：输入的文字和当前日期时间覆盖数据库中对应的记录 布局包括EditText和两个Button+活动中为两个按钮设置点击监听事件： 返回按钮同新增活动中的取消按钮 保存按钮同新增按钮中的保存按钮 活动中的EditText除了要显示原有的备忘内容外，还要有可以编辑的属性： 1234u_edtxt.setText(this.getIntent().getStringExtra(NotesDB.CONTENT));u_edtxt. setCursorVisible (true) ;u_edtxt.setFocusable(true);u_edtxt.setSelection(u_edtxt.getText().toString().length()); 在Manifest文件中注册活动：12345678910111213141516171819202122232425262728293031323334353637&lt;application android:allowBackup=&quot;true&quot; android:icon=&quot;@mipmap/ic_note_white&quot; android:label=&quot;@string/app_name&quot; android:supportsRtl=&quot;true&quot; android:theme=&quot;@style/AppTheme.NoActionBar&quot;&gt; &lt;activity android:name=&quot;.activity.MainActivity&quot; android:label=&quot;@string/app_name&quot; android:launchMode=&quot;singleTask&quot; android:screenOrientation=&quot;portrait&quot; android:theme=&quot;@style/AppTheme.NoActionBar&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt; &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;activity android:name=&quot;.activity.AddContent&quot; android:label=&quot;新增日程&quot; android:screenOrientation=&quot;portrait&quot; android:theme=&quot;@style/AppTheme.NoActionBar&quot; android:windowSoftInputMode=&quot;adjustResize&quot;&gt;&lt;/activity&gt; &lt;activity android:name=&quot;.activity.ShowContent&quot; android:label=&quot;查看日程&quot; android:screenOrientation=&quot;portrait&quot; android:theme=&quot;@style/AppTheme.NoActionBar&quot;&gt;&lt;/activity&gt; &lt;activity android:name=&quot;.activity.UpdateContent&quot; android:label=&quot;修改日程&quot; android:screenOrientation=&quot;portrait&quot; android:theme=&quot;@style/AppTheme.NoActionBar&quot; android:windowSoftInputMode=&quot;adjustResize&quot;&gt;&lt;/activity&gt; &lt;/application&gt; 至此，备忘录的增删改查功能已经添加完毕。"},{"title":"遇到乱码问题的解决方案","date":"2017-03-29T14:25:23.000Z","path":"2017/03/29/04_GBK和UTF-8的区别/","text":"编码的概念 GBK编码：是指中国的中文字符，其它它包含了简体中文与繁体中文字符，另外还有一种字符“gb2312”，这种字符仅能存储简体中文字符。 UTF-8编码：它是一种全国家通过的一种编码，如果你的网站涉及到多个国家的语言，那么建议你选择UTF-8编码。 GBK和UTF8有什么区别？ UTF8编码格式很强大，支持所有国家的语言，正是因为它的强大，才会导致它占用的空间大小要比GBK大，对于网站打开速度而言，也是有一定影响的。 GBK编码格式，它的功能少，仅限于中文字符，当然它所占用的空间大小会随着它的功能而减少，打开网页的速度比较快。 如何在sublime中添加对中文的支持 首先安装Package control工具：在Sublime Text里，按ctrl+`，打开Console，一次性输入如下代码： 1import urllib.request,os; pf = &apos;Package Control.sublime-package&apos;; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); open(os.path.join(ipp, pf), &apos;wb&apos;).write(urllib.request.urlopen( &apos;http://sublime.wbond.net/&apos; + pf.replace(&apos; &apos;,&apos;%20&apos;)).read()) 然后按ctrl shift p 打开命令行模式：输入Install Package关键字，然后点击自动出现的下拉菜单里的第一项：Package Control: Install Package(回车无效) PS：执行上述步骤不要急，左下角会有一个等于号来回动，看着它也许你会安静点。。 稍等一会，会再次在命令行下弹出一个下拉菜单。输入“ConvertToUTF8”或者“GBK Encoding Support”，选择匹配项。中文字符就可以正常显示了。 Tips： 养成将手敲的代码存为 UTF-8 编码格式的习惯 遇到乱码首先尝试转 UTF-8 切忌一看到乱码先乱删一通，然后气急败坏地把代码文件全删了"},{"title":"冒泡排序算法","date":"2017-03-26T15:56:26.000Z","path":"2017/03/26/03_冒泡排序算法/","text":"(对 n 个数降序)冒泡排序的思路是： 1、最多进行 (n-1) 次排序 2、每次排序将从第一个开始遍历和后一个数比较（确定是否执行交换位置） 值得注意的是本次排序后会产生一个最小数，下次排序可以不用和该数进行比较的判断 关于复杂度的概念还未与其他排序算法比较 代码如下：1234567891011121314151617181920212223242526272829303132public class MyBubbleSort &#123; public static void main(String[] args) &#123; int[] arr = &#123;2,6,3,9,4,5,1,2,5,8&#125;; int len = arr.length; for (int i=0;i&lt;len-1;i++) &#123; for (int j=0;j&lt;len-1-i;j++)//减i的原因是经过i+1次排序后倒数第i+1个数都是确认最小的 &#123; if(arr[j]&lt;arr[j+1]) &#123; int temp = 0; temp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = temp; &#125; &#125; System.out.print(&quot;第&quot;+(i+1)+&quot;次排序结果:&quot;); for(int a = 0; a &lt;len;a++) &#123; System.out.print(arr[a] + &quot;\\t&quot;); &#125; System.out.println(&quot;&quot;); &#125; System.out.print(&quot;最终排序结果为：&quot;); for(int a = 0; a &lt;len;a++) &#123; System.out.print(arr[a] + &quot;\\t&quot;); &#125; System.out.println(&quot;&quot;); &#125;&#125;"},{"title":"git常用命令","date":"2017-01-13T17:21:22.000Z","path":"2017/01/14/02_git常用命令/","text":"创建本地仓库git init.git所在文件夹便是git对应的一个本地仓库 创建本地分支git branch master 查看本地分支git branch 设置远程仓库地址git remote add github git@github.com:regeorge/blog.git 查看已配置的远程仓库git remote 从远程仓库更新到本地分支git pull github master 在未加入缓存区时回滚git checkout -- . 将本文件夹内所有改动加入缓存区git add . 在加入缓存区时回滚git reset HEAD 将暂存区的改动提交到本地仓库git commit -m &quot;add all files&quot; 在提交仓库后回滚git log #查看提交记录（带有唯一标识commitid） git revert %commitid% 将本地分支推送到远程仓库git push github master .gitignore文件中写入不需要同步的文件夹路径hexo deploy 命令在使用hexo搭建博客时，blog目录下有一个.git文件夹，而.deploy_git文件夹内的.git文件夹又对应了另一个仓库,hexo d命令正是将此目录下的仓库推送到远程仓库从而实现更新博客的 FAQ Q1：在github上创建仓库，在本地新建仓库并push产生冲突 A1：先pull后pushgit push -u origin master -f 参考：http://wuchong.me/blog/2014/01/17/use-github-to-manage-hexo-source/ http://blog.csdn.net/shiren1118/article/details/7761203"},{"title":"如何搭建个人博客","date":"2017-01-09T14:27:45.000Z","path":"2017/01/09/01_如何搭建个人博客/","text":"搭建个人主页的步骤如下： 先将我们写的文章或者照片生成静态页面(hexo) 并将这些静态页面部署到支持静态页面的服务器(github或coding) 这样我们就可以通过服务器的域名地址访问到自己的博客了(regeorge.github.io) 下面是操作步骤： 准备环境： node.js（npm）的安装 1、hexo 是基于 node.js 来生成页面的 2、node.js 提供了 npm 包管理工具，后面安装 hexo 只需要几行命令 hexo 的安装和初始化 1、完成后可以在本地生成默认的博客页面，并通过浏览器预览效果 2、常用的几条命令如下： hexo n p &apos;文章标题&apos; //新建文章 hexo g //生成页面 hexo s //本地预览 hexo d //提交页面 git 的安装和配置 1、git是用作版本控制的，也就是在本地生成的博客都是通过git来同步到云端服务器 2、上一条的提交页面命令hexo d其实就是通过git将页面提交到配置文件中填写的github仓库的 github 的注册和配置 1、github 提供了一个静态页面服务功能，这里要做的是在github上创建一个指定名称的仓库来放置本地生成好的博客页面文件 2、同时还需要把这个创建好的仓库地址填写到本地的配置信息中 具体的安装步骤请参考gdutxiaoxu的文章，每一步都非常详细：手把手教你用Hexo+Github 搭建属于自己的博客 配置主题跟着上述参考文章的操作步骤配置好环境后，已经可以在本地预览到生成的博客界面了，按照这种方法生成的页面其实都是一样的，要让自己的博客不一样，一是要时常更新自己的文章，二是自定义页面的样式，网上也提供了很多开源的主题可以配置，非常方便，我推荐的主题有Next，Yilia，Yelee，更多的主题可以百度hexo theme 配置的方法就是将主题通过git pull到博客的theme目录下，然后按照该主题的说明文档（github上的readme.md）进行修改自定义的配置 提交页面假设我们已经上面的参考文章配置好了提交的地址：在博客的根目录的配置文件_config.yml中 # Deployment deploy: type: git repo: github: git@github.com:reGeorge/regeorge.github.io.git,master //github仓库 coding: git@git.coding.net:reGeorge/reGeorge.git,master //coding仓库 branch: master 这里我配置了两个地址，执行hexo d命令时会分别向两个仓库推送本地生成的页面，这样我通过两个域名都可以访问到我的博客（coding国内访问的速度更快） https://regeorge.github.io/ http://regeorge.coding.me/"}]